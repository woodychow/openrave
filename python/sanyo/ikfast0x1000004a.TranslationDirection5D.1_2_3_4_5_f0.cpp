/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x1000004a generated on 2018-02-22 13:38:07.119154
/// Generated using solver translationdirection5d
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x1000004a);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26;
x0=IKsin(j[0]);
x1=IKcos(j[0]);
x2=IKcos(j[2]);
x3=IKcos(j[1]);
x4=IKsin(j[1]);
x5=IKsin(j[3]);
x6=IKsin(j[2]);
x7=IKcos(j[3]);
x8=IKsin(j[4]);
x9=IKcos(j[4]);
x10=((0.0005)*x7);
x11=((1.0)*x8);
x12=((1.0)*x9);
x13=(x2*x3);
x14=(x4*x6);
x15=(x5*x8);
x16=(x3*x6);
x17=(x7*x8);
x18=(x2*x4);
x19=((0.037)*x15);
x20=(x10+x19);
x21=((((0.037)*x14))+(((-0.037)*x13)));
x22=((((-1.0)*x13))+(((1.0)*x14)));
x23=((((0.037)*x18))+(((0.037)*x16)));
x24=((((1.0)*x16))+(((1.0)*x18)));
x25=((((-1.0)*x12*x22))+(((-1.0)*x11*x24*x7)));
x26=((((-1.0)*x11*x23*x7))+(((0.213)*x13))+(((-1.0)*x12*x21))+(((0.1015)*x18))+(((0.1015)*x16))+((x5*(((((0.0005)*x16))+(((0.0005)*x18))))))+(((0.13)*x4))+(((-0.213)*x14)));
eetrans[0]=((((0.0385)*x0))+((x1*x26))+((x0*(((-0.0135)+(((-1.0)*x20))))))+(((0.035)*x1)));
eetrans[1]=(((x0*x26))+(((0.035)*x0))+(((-0.0385)*x1))+((x1*(((0.0135)+x20)))));
eetrans[2]=((0.258)+((x5*(((((-0.0005)*x14))+(((0.0005)*x13))))))+(((0.1015)*x13))+((x17*x21))+(((0.13)*x3))+(((-0.1015)*x14))+(((-1.0)*x23*x9))+(((-0.213)*x16))+(((-0.213)*x18)));
eerot[0]=(((x1*x25))+(((-1.0)*x0*x11*x5)));
eerot[1]=(((x0*x25))+((x1*x15)));
eerot[2]=((((-1.0)*x24*x9))+((x17*x22)));
}

IKFAST_API int GetNumFreeParameters() { return 1; }
IKFAST_API int* GetFreeParameters() { static int freeparams[] = {0}; return freeparams; }
IKFAST_API int GetNumJoints() { return 6; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x56000007; }

class IKSolver {
public:
IkReal j1,cj1,sj1,htj1,j1mul,j2,cj2,sj2,htj2,j2mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,j5,cj5,sj5,htj5,j5mul,j0,cj0,sj0,htj0,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij1[2], _nj1,_ij2[2], _nj2,_ij3[2], _nj3,_ij4[2], _nj4,_ij5[2], _nj5,_ij0[2], _nj0;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {

    for (int i=0; i<3; ++i)
        printf("%f ", eetrans[i]);
    // printf("\n");
    for (int i=0; i<9; ++i)
        printf("%f ", eerot[i]);
    printf("\n");

    
j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1;  _ij0[0] = -1; _ij0[1] = -1; _nj0 = 0; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

j0=pfree[0]; cj0=cos(pfree[0]); sj0=sin(pfree[0]);
r00 = eerot[0];
r01 = eerot[1];
r02 = eerot[2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];
new_r00=((((-1.0)*r01*(IKsin(j0))))+(((-1.0)*r00*(IKcos(j0)))));
IkReal x27=IKcos(j0);
IkReal x28=IKsin(j0);
new_px=((0.035)+(((-1.0)*px*x27))+(((-1.0)*py*x28))+(((0.027)*r01*x28))+(((0.027)*r00*x27)));
new_r01=r02;
new_py=((-0.258)+(((-0.027)*r02))+pz);
new_r02=((((-1.0)*r00*(IKsin(j0))))+((r01*(IKcos(j0)))));
IkReal x29=IKcos(j0);
IkReal x30=IKsin(j0);
new_pz=((0.0385)+((py*x29))+(((0.027)*r00*x30))+(((-0.027)*r01*x29))+(((-1.0)*px*x30)));
r00 = new_r00; r01 = new_r01; r02 = new_r02; px = new_px; py = new_py; pz = new_pz;

pp=((px*px)+(py*py)+(pz*pz));
IkReal op[18], zeror[32];
int numroots;;
IkReal x31=((-0.014)+pz);
IkReal x32=((-0.013)+pz);
op[0]=r02;
op[1]=0;
op[2]=r02;
op[3]=x31;
op[4]=0;
op[5]=x32;
op[6]=0;
op[7]=-4.0;
op[8]=0;
op[9]=0;
op[10]=-0.148;
op[11]=0;
op[12]=r02;
op[13]=0;
op[14]=r02;
op[15]=x31;
op[16]=0;
op[17]=x32;
solvedialyticpoly8qep(op,zeror,numroots);
IkReal j4array[16], cj4array[16], sj4array[16], j3array[16], cj3array[16], sj3array[16];
int numsolutions = 0;
for(int ij4 = 0; ij4 < numroots; ij4 += 2)
{
IkReal htj4 = zeror[ij4+0], htj3 = zeror[ij4+1];
if(isnan(htj4)||isnan(htj3)){
continue;
}
j4array[numsolutions]=((2.0)*(atan(htj4)));
j3array[numsolutions]=((2.0)*(atan(htj3)));
if(isinf(htj4)){
cj4array[numsolutions] = IKcos(j4array[numsolutions]);
sj4array[numsolutions] = IKsin(j4array[numsolutions]);
}
else{
IkReal x33=htj4*htj4;
CheckValue<IkReal> x34=IKPowWithIntegerCheck(((1.0)+x33),-1);
if(!x34.valid){
continue;
}
cj4array[numsolutions]=((x34.value)*(((1.0)+(((-1.0)*x33)))));
CheckValue<IkReal> x35=IKPowWithIntegerCheck(((1.0)+(htj4*htj4)),-1);
if(!x35.valid){
continue;
}
sj4array[numsolutions]=((2.0)*htj4*(x35.value));
}
if(isinf(htj3)){
cj3array[numsolutions] = IKcos(j3array[numsolutions]);
sj3array[numsolutions] = IKsin(j3array[numsolutions]);
}
else{
IkReal x36=htj3*htj3;
CheckValue<IkReal> x37=IKPowWithIntegerCheck(((1.0)+x36),-1);
if(!x37.valid){
continue;
}
cj3array[numsolutions]=((x37.value)*(((1.0)+(((-1.0)*x36)))));
CheckValue<IkReal> x38=IKPowWithIntegerCheck(((1.0)+(htj3*htj3)),-1);
if(!x38.valid){
continue;
}
sj3array[numsolutions]=((2.0)*htj3*(x38.value));
}
if( j4array[numsolutions] > IKPI )
{
    j4array[numsolutions]-=IK2PI;
}
else if( j4array[numsolutions] < -IKPI )
{
    j4array[numsolutions]+=IK2PI;
}
if( j3array[numsolutions] > IKPI )
{
    j3array[numsolutions]-=IK2PI;
}
else if( j3array[numsolutions] < -IKPI )
{
    j3array[numsolutions]+=IK2PI;
}
numsolutions++;
}
bool j4valid[16]={true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true};
_nj4 = 16;
_nj3 = 1;
for(int ij4 = 0; ij4 < numsolutions; ++ij4)
    {
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
_ij3[0] = 0; _ij3[1] = -1;
for(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)
{
if( !j4valid[iij4] ) { continue; }
if( IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(cj3array[ij4]-cj3array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij4]-sj3array[iij4]) < IKFAST_SOLUTION_THRESH &&  1 )
{
    j4valid[iij4]=false; _ij4[1] = iij4; _ij3[1] = 0;  break; 
}
}
    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

    j3 = j3array[ij4]; cj3 = cj3array[ij4]; sj3 = sj3array[ij4];

innerfn(solutions);
    }
}
return solutions.GetNumSolutions()>0;
}
static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
inline void innerfn(IkSolutionListBase<IkReal>& solutions) {
for(int fniter = 0; fniter < 1; ++fniter) {
{
IkReal j2eval[1];
IkReal x39=r00*r00;
IkReal x40=r01*r01;
IkReal x41=(py*r00);
IkReal x42=((12.0)*cj3);
IkReal x43=((4.0)*sj4);
IkReal x44=((0.148)*cj4);
IkReal x45=((4.0)*sj3);
IkReal x46=((12.0)*sj4);
IkReal x47=(px*r01);
IkReal x48=((0.444)*cj4);
IkReal x49=((12.0)*sj3);
IkReal x50=((4.0)*cj3);
IkReal x51=((2.556)*x40);
IkReal x52=(cj3*x39);
IkReal x53=(cj4*py*r01);
IkReal x54=(cj3*x40);
IkReal x55=(sj3*x39);
IkReal x56=(sj3*x40);
IkReal x57=(cj4*px*r00);
IkReal x58=(sj3*x57);
j2eval[0]=((((0.5)*(IKabs(((((-1.0)*x45*x53))+(((-1.0)*x45*x57))+(((-1.0)*r02*x47*x50))+((r02*x41*x50))+((x44*x55))+((x44*x56))+(((0.852)*x55))+(((0.852)*x56)))))))+(IKabs(((((-1.04)*x55))+(((-1.04)*x56)))))+(((0.5)*(IKabs((((x41*x43))+((x44*x52))+((x44*x54))+(((-1.0)*x43*x47))+(((-1.0)*r02*x41*x45))+((r02*x45*x47))+(((-1.0)*x50*x53))+(((-1.0)*x50*x57))+(((0.852)*x52))+(((0.852)*x54)))))))+(IKabs(((((-1.04)*x54))+(((-1.04)*x52)))))+(IKabs((((sj3*x51))+((r02*x41*x42))+(((2.556)*x55))+(((-1.0)*x49*x53))+(((-1.0)*x49*x57))+(((-1.0)*r02*x42*x47))+((x48*x55))+((x48*x56)))))+(IKabs((((x41*x46))+(((2.556)*x52))+(((-1.0)*x42*x57))+(((-1.0)*x42*x53))+((r02*x47*x49))+((x48*x52))+((x48*x54))+(((-1.0)*r02*x41*x49))+((cj3*x51))+(((-1.0)*x46*x47)))))+(((0.5)*(IKabs(((((-2.08)*x55))+(((-2.08)*x56)))))))+(((0.5)*(IKabs(((((-2.08)*x54))+(((-2.08)*x52))))))));
if( IKabs(j2eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1, j2, j5]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j2evalpoly[1];
IkReal x59=r00*r00;
IkReal x60=r01*r01;
IkReal x61=((0.444)*cj4);
IkReal x62=(py*r00);
IkReal x63=(px*r01);
IkReal x64=((0.148)*cj4);
IkReal x65=(cj4*sj3);
IkReal x66=(px*r00);
IkReal x67=(py*r01);
IkReal x68=(sj3*x60);
IkReal x69=((12.0)*cj3*r02);
IkReal x70=(sj3*x59);
IkReal x71=((4.0)*cj3*r02);
IkReal x72=((((-1.04)*x70))+(((-1.04)*x68)));
IkReal x73=((((2.556)*x68))+((x62*x69))+((x61*x68))+(((2.556)*x70))+((x61*x70))+(((-1.0)*x63*x69))+(((-12.0)*x65*x66))+(((-12.0)*x65*x67)));
IkReal x74=((((-1.0)*x63*x71))+(((-4.0)*x65*x66))+(((-4.0)*x65*x67))+((x62*x71))+((x64*x70))+((x64*x68))+(((0.852)*x70))+(((0.852)*x68)));
op[0]=x74;
op[1]=x72;
op[2]=x73;
op[3]=((((-2.08)*x70))+(((-2.08)*x68)));
op[4]=x73;
op[5]=x72;
op[6]=x74;
polyroots6(op,zeror,numroots);
IkReal j2array[6], cj2array[6], sj2array[6], tempj2array[1];
int numsolutions = 0;
for(int ij2 = 0; ij2 < numroots; ++ij2)
{
IkReal htj2 = zeror[ij2];
tempj2array[0]=((2.0)*(atan(htj2)));
for(int kj2 = 0; kj2 < 1; ++kj2)
{
j2array[numsolutions] = tempj2array[kj2];
if( j2array[numsolutions] > IKPI )
{
    j2array[numsolutions]-=IK2PI;
}
else if( j2array[numsolutions] < -IKPI )
{
    j2array[numsolutions]+=IK2PI;
}
sj2array[numsolutions] = IKsin(j2array[numsolutions]);
cj2array[numsolutions] = IKcos(j2array[numsolutions]);
numsolutions++;
}
}
bool j2valid[6]={true,true,true,true,true,true};
_nj2 = 6;
for(int ij2 = 0; ij2 < numsolutions; ++ij2)
    {
if( !j2valid[ij2] )
{
    continue;
}
    j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
htj2 = IKtan(j2/2);

IkReal x75=r01*r01;
IkReal x76=r00*r00;
IkReal x77=((12.0)*px);
IkReal x78=(r01*sj4);
IkReal x79=((0.444)*cj4);
IkReal x80=((4.0)*px);
IkReal x81=((0.148)*cj4);
IkReal x82=(cj3*x76);
IkReal x83=(py*r00*sj4);
IkReal x84=(cj3*x75);
IkReal x85=(cj3*cj4*r00);
IkReal x86=(r01*r02*sj3);
IkReal x87=((4.0)*x83);
IkReal x88=((0.852)*x82);
IkReal x89=((0.852)*x84);
IkReal x90=(py*r00*r02*sj3);
IkReal x91=(cj3*cj4*py*r01);
IkReal x92=(x81*x82);
IkReal x93=(x81*x84);
IkReal x94=(x80*x86);
IkReal x95=((((-1.04)*x82))+(((-1.04)*x84)));
IkReal x96=(((x78*x80))+(((4.0)*x90))+(((4.0)*x91))+((x80*x85)));
IkReal x97=(x88+x89+x87+x93+x92+x94);
IkReal x98=(((x77*x86))+(((12.0)*x83))+((x79*x84))+((x79*x82))+(((-1.0)*x77*x85))+(((2.556)*x84))+(((2.556)*x82))+(((-12.0)*x90))+(((-12.0)*x91))+(((-1.0)*x77*x78)));
j2evalpoly[0]=(((x95*(htj2*htj2*htj2*htj2*htj2)))+((htj2*x95))+((x98*(htj2*htj2)))+(((htj2*htj2*htj2*htj2*htj2*htj2)*((x97+(((-1.0)*x96))))))+(((htj2*htj2*htj2)*(((((-2.08)*x82))+(((-2.08)*x84))))))+x97+(((-1.0)*x96))+((x98*(htj2*htj2*htj2*htj2))));
if( IKabs(j2evalpoly[0]) > 0.0000001000000000  )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < numsolutions; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
{
IkReal j1eval[3];
IkReal x99=((1.0)*r00);
IkReal x100=(cj3*r02);
IkReal x101=(cj2*r01);
IkReal x102=(cj4*sj3);
IkReal x103=(sj2*x102);
IkReal x104=((((-1.0)*sj3))+((sj3*(r02*r02))));
j1eval[0]=x104;
j1eval[1]=IKsign(x104);
j1eval[2]=((IKabs(((((-1.0)*x103*x99))+(((-1.0)*cj2*x100*x99))+(((-1.0)*r01*sj2*x100))+((x101*x102)))))+(IKabs((((cj2*r00*x102))+((r01*x103))+(((-1.0)*sj2*x100*x99))+((x100*x101))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x105=(((cj3*(r02*r02)))+(((-1.0)*cj3)));
j1eval[0]=x105;
j1eval[1]=IKsign(x105);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x106=((((-1.0)*px*r01))+((py*r00)));
j1eval[0]=x106;
j1eval[1]=IKsign(x106);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
sj3=1.0;
cj3=0;
j3=1.5707963267949;
IkReal x107=(cj2*cj4);
IkReal x108=(cj4*sj2);
IkReal x109=((-1.0)+(r02*r02));
j1eval[0]=x109;
j1eval[1]=IKsign(x109);
j1eval[2]=((IKabs((((r01*x107))+(((-1.0)*r00*x108)))))+(IKabs((((r01*x108))+((r00*x107))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
sj3=1.0;
cj3=0;
j3=1.5707963267949;
IkReal x110=cj2*cj2;
IkReal x111=((0.13)*r01);
IkReal x112=(cj2*sj2);
IkReal x113=((0.13)*r00);
IkReal x114=((0.102)*r01);
IkReal x115=((0.102)*r00);
IkReal x116=(((px*r01))+(((-1.0)*py*r00)));
j1eval[0]=x116;
j1eval[1]=((IKabs(((((-1.0)*x111*x112))+(((-1.0)*cj2*x115))+(((-1.0)*x110*x113))+(((-1.0)*sj2*x114)))))+(IKabs((((x112*x113))+((sj2*x115))+(((-1.0)*cj2*x114))+(((-1.0)*x110*x111))))));
j1eval[2]=IKsign(x116);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
sj3=1.0;
cj3=0;
j3=1.5707963267949;
IkReal x117=cj2*cj2;
IkReal x118=(cj4*py);
IkReal x119=((0.13)*r01);
IkReal x120=(cj2*sj2);
IkReal x121=((0.102)*cj2);
IkReal x122=((1.0)*px);
IkReal x123=((0.13)*r00);
IkReal x124=((0.102)*sj2);
IkReal x125=((((-1.0)*r00*x122))+(((-1.0)*py*r01)));
j1eval[0]=x125;
j1eval[1]=((IKabs(((((-1.0)*x117*x119))+((sj2*x118))+((cj2*cj4*px))+((r00*x124))+((x120*x123))+(((-1.0)*r01*x121)))))+(IKabs((((x117*x123))+((cj2*x118))+(((-1.0)*cj4*sj2*x122))+((r01*x124))+((r00*x121))+((x119*x120))))));
j1eval[2]=IKsign(x125);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
sj3=1.0;
cj3=0;
j3=1.5707963267949;
sj4=1.0;
cj4=0;
j4=1.5707963267949;
IkReal x126=cj2*cj2;
IkReal x127=((0.13)*r01);
IkReal x128=(cj2*sj2);
IkReal x129=((0.102)*cj2);
IkReal x130=((0.13)*r00);
IkReal x131=((0.102)*sj2);
IkReal x132=(((px*r00))+((py*r01)));
j1eval[0]=x132;
j1eval[1]=((IKabs((((r01*x129))+(((-1.0)*x128*x130))+((x126*x127))+(((-1.0)*r00*x131)))))+(IKabs(((((-1.0)*r00*x129))+(((-1.0)*r01*x131))+(((-1.0)*x126*x130))+(((-1.0)*x127*x128))))));
j1eval[2]=IKsign(x132);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
sj3=1.0;
cj3=0;
j3=1.5707963267949;
sj4=1.0;
cj4=0;
j4=1.5707963267949;
IkReal x133=cj2*cj2;
IkReal x134=((0.13)*r01);
IkReal x135=(cj2*sj2);
IkReal x136=((0.13)*r00);
IkReal x137=((0.102)*r01);
IkReal x138=((0.102)*r00);
IkReal x139=(((px*r01))+(((-1.0)*py*r00)));
j1eval[0]=x139;
j1eval[1]=((IKabs(((((-1.0)*sj2*x137))+(((-1.0)*x134*x135))+(((-1.0)*x133*x136))+(((-1.0)*cj2*x138)))))+(IKabs((((x135*x136))+((sj2*x138))+(((-1.0)*x133*x134))+(((-1.0)*cj2*x137))))));
j1eval[2]=IKsign(x139);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
sj3=1.0;
cj3=0;
j3=1.5707963267949;
sj4=1.0;
cj4=0;
j4=1.5707963267949;
IkReal x140=cj2*cj2;
IkReal x141=((0.213)*sj2);
IkReal x142=((0.13)*r01);
IkReal x143=(cj2*sj2);
IkReal x144=((0.213)*cj2);
IkReal x145=((0.13)*r00);
IkReal x146=(((px*r01))+(((-1.0)*py*r00)));
j1eval[0]=x146;
j1eval[1]=IKsign(x146);
j1eval[2]=((IKabs(((((-1.0)*x142))+((x140*x142))+(((-1.0)*x143*x145))+((r01*x141))+((r00*x144)))))+(IKabs(((((-1.0)*x145))+((x140*x145))+((x142*x143))+((r00*x141))+(((-1.0)*r01*x144))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
sj3=1.0;
cj3=0;
j3=1.5707963267949;
sj4=1.0;
cj4=0;
j4=1.5707963267949;
px=0;
py=0;
pp=pz*pz;
j1eval[0]=((1.0)+(((-1.0)*(r02*r02))));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x148 = IKatan2WithCheck(IkReal(((((1.63846153846154)*r01))+(((-0.784615384615385)*r00)))),IkReal(((((-1.63846153846154)*r00))+(((-0.784615384615385)*r01)))),IKFAST_ATAN2_MAGTHRESH);
if(!x148.valid){
continue;
}
IkReal x147=x148.value;
j1array[0]=((-1.0)*x147);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x147)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[1];
IkReal x149=IKsin(j1);
IkReal x150=IKcos(j1);
evalcond[0]=((((-1.63846153846154)*r01*x149))+(((-1.63846153846154)*r00*x150))+(((-0.784615384615385)*r01*x150))+(((0.784615384615385)*r00*x149)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1, j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x151=cj2*cj2;
IkReal x152=((0.213)*sj2);
IkReal x153=((0.13)*r01);
IkReal x154=(cj2*sj2);
IkReal x155=((0.213)*cj2);
IkReal x156=((0.13)*r00);
CheckValue<IkReal> x157=IKPowWithIntegerCheck(IKsign((((px*r01))+(((-1.0)*py*r00)))),-1);
if(!x157.valid){
continue;
}
CheckValue<IkReal> x158 = IKatan2WithCheck(IkReal(((((-1.0)*x153))+(((-1.0)*x154*x156))+((r00*x155))+((r01*x152))+((x151*x153)))),IkReal((((x153*x154))+(((-1.0)*x156))+((r00*x152))+((x151*x156))+(((-1.0)*r01*x155)))),IKFAST_ATAN2_MAGTHRESH);
if(!x158.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x157.value)))+(x158.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x159=IKcos(j1);
IkReal x160=IKsin(j1);
IkReal x161=(cj2*py);
IkReal x162=((1.0)*sj2);
IkReal x163=((1.0)*cj2);
IkReal x164=(px*x159);
IkReal x165=(r00*x159);
IkReal x166=(sj2*x159);
IkReal x167=(r00*x160);
IkReal x168=(px*x160);
IkReal x169=(r01*x160);
evalcond[0]=(((r01*x166))+((cj2*x165))+((cj2*x169))+(((-1.0)*x162*x167)));
evalcond[1]=(((cj2*r01*x159))+(((-1.0)*x163*x167))+(((-1.0)*x162*x165))+(((-1.0)*x162*x169)));
evalcond[2]=((0.213)+((py*x166))+((cj2*x164))+(((-1.0)*x162*x168))+(((-0.13)*sj2))+((x160*x161)));
evalcond[3]=((-0.102)+(((-1.0)*x163*x168))+(((-1.0)*x162*x164))+(((-1.0)*py*x160*x162))+(((-0.13)*cj2))+((x159*x161)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x170=cj2*cj2;
IkReal x171=((0.13)*r01);
IkReal x172=(cj2*sj2);
IkReal x173=((0.102)*cj2);
IkReal x174=((0.13)*r00);
IkReal x175=((0.102)*sj2);
CheckValue<IkReal> x176 = IKatan2WithCheck(IkReal((((r00*x175))+((x172*x174))+(((-1.0)*r01*x173))+(((-1.0)*x170*x171)))),IkReal(((((-1.0)*r00*x173))+(((-1.0)*r01*x175))+(((-1.0)*x170*x174))+(((-1.0)*x171*x172)))),IKFAST_ATAN2_MAGTHRESH);
if(!x176.valid){
continue;
}
CheckValue<IkReal> x177=IKPowWithIntegerCheck(IKsign((((px*r01))+(((-1.0)*py*r00)))),-1);
if(!x177.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x176.value)+(((1.5707963267949)*(x177.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x178=IKcos(j1);
IkReal x179=IKsin(j1);
IkReal x180=(cj2*py);
IkReal x181=((1.0)*sj2);
IkReal x182=((1.0)*cj2);
IkReal x183=(px*x178);
IkReal x184=(r00*x178);
IkReal x185=(sj2*x178);
IkReal x186=(r00*x179);
IkReal x187=(px*x179);
IkReal x188=(r01*x179);
evalcond[0]=(((r01*x185))+((cj2*x184))+((cj2*x188))+(((-1.0)*x181*x186)));
evalcond[1]=(((cj2*r01*x178))+(((-1.0)*x182*x186))+(((-1.0)*x181*x184))+(((-1.0)*x181*x188)));
evalcond[2]=((0.213)+((x179*x180))+((cj2*x183))+(((-0.13)*sj2))+((py*x185))+(((-1.0)*x181*x187)));
evalcond[3]=((-0.102)+(((-1.0)*py*x179*x181))+((x178*x180))+(((-0.13)*cj2))+(((-1.0)*x182*x187))+(((-1.0)*x181*x183)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x189=cj2*cj2;
IkReal x190=((0.13)*r01);
IkReal x191=(cj2*sj2);
IkReal x192=((0.102)*cj2);
IkReal x193=((0.13)*r00);
IkReal x194=((0.102)*sj2);
CheckValue<IkReal> x195 = IKatan2WithCheck(IkReal(((((-1.0)*r00*x192))+(((-1.0)*r01*x194))+(((-1.0)*x189*x193))+(((-1.0)*x190*x191)))),IkReal(((((-1.0)*r00*x194))+(((-1.0)*x191*x193))+((r01*x192))+((x189*x190)))),IKFAST_ATAN2_MAGTHRESH);
if(!x195.valid){
continue;
}
CheckValue<IkReal> x196=IKPowWithIntegerCheck(IKsign((((px*r00))+((py*r01)))),-1);
if(!x196.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x195.value)+(((1.5707963267949)*(x196.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x197=IKcos(j1);
IkReal x198=IKsin(j1);
IkReal x199=(cj2*py);
IkReal x200=((1.0)*sj2);
IkReal x201=((1.0)*cj2);
IkReal x202=(px*x197);
IkReal x203=(r00*x197);
IkReal x204=(sj2*x197);
IkReal x205=(r00*x198);
IkReal x206=(px*x198);
IkReal x207=(r01*x198);
evalcond[0]=((((-1.0)*x200*x205))+((cj2*x203))+((cj2*x207))+((r01*x204)));
evalcond[1]=((((-1.0)*x200*x207))+(((-1.0)*x200*x203))+((cj2*r01*x197))+(((-1.0)*x201*x205)));
evalcond[2]=((0.213)+(((-1.0)*x200*x206))+((cj2*x202))+((x198*x199))+((py*x204))+(((-0.13)*sj2)));
evalcond[3]=((-0.102)+(((-1.0)*x200*x202))+(((-1.0)*x201*x206))+(((-1.0)*py*x198*x200))+(((-0.13)*cj2))+((x197*x199)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
sj3=1.0;
cj3=0;
j3=1.5707963267949;
sj4=-1.0;
cj4=0;
j4=-1.5707963267949;
IkReal x208=cj2*cj2;
IkReal x209=((0.13)*r01);
IkReal x210=(cj2*sj2);
IkReal x211=((0.102)*cj2);
IkReal x212=((0.13)*r00);
IkReal x213=((0.102)*sj2);
IkReal x214=(((px*r00))+((py*r01)));
j1eval[0]=x214;
j1eval[1]=((IKabs(((((-1.0)*r01*x213))+(((-1.0)*r00*x211))+(((-1.0)*x208*x212))+(((-1.0)*x209*x210)))))+(IKabs(((((-1.0)*x210*x212))+(((-1.0)*r00*x213))+((r01*x211))+((x208*x209))))));
j1eval[2]=IKsign(x214);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
sj3=1.0;
cj3=0;
j3=1.5707963267949;
sj4=-1.0;
cj4=0;
j4=-1.5707963267949;
IkReal x215=cj2*cj2;
IkReal x216=((0.13)*r01);
IkReal x217=(cj2*sj2);
IkReal x218=((0.13)*r00);
IkReal x219=((0.102)*r01);
IkReal x220=((0.102)*r00);
IkReal x221=(((px*r01))+(((-1.0)*py*r00)));
j1eval[0]=x221;
j1eval[1]=((IKabs(((((-1.0)*cj2*x219))+((sj2*x220))+((x217*x218))+(((-1.0)*x215*x216)))))+(IKabs(((((-1.0)*sj2*x219))+(((-1.0)*cj2*x220))+(((-1.0)*x216*x217))+(((-1.0)*x215*x218))))));
j1eval[2]=IKsign(x221);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
sj3=1.0;
cj3=0;
j3=1.5707963267949;
sj4=-1.0;
cj4=0;
j4=-1.5707963267949;
IkReal x222=cj2*cj2;
IkReal x223=((0.213)*sj2);
IkReal x224=((0.13)*r01);
IkReal x225=(cj2*sj2);
IkReal x226=((0.213)*cj2);
IkReal x227=((0.13)*r00);
IkReal x228=(((px*r01))+(((-1.0)*py*r00)));
j1eval[0]=x228;
j1eval[1]=IKsign(x228);
j1eval[2]=((IKabs((((x224*x225))+((x222*x227))+((r00*x223))+(((-1.0)*r01*x226))+(((-1.0)*x227)))))+(IKabs((((x222*x224))+((r01*x223))+((r00*x226))+(((-1.0)*x225*x227))+(((-1.0)*x224))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
sj3=1.0;
cj3=0;
j3=1.5707963267949;
sj4=-1.0;
cj4=0;
j4=-1.5707963267949;
px=0;
py=0;
pp=pz*pz;
j1eval[0]=((1.0)+(((-1.0)*(r02*r02))));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x230 = IKatan2WithCheck(IkReal(((((1.63846153846154)*r01))+(((-0.784615384615385)*r00)))),IkReal(((((-1.63846153846154)*r00))+(((-0.784615384615385)*r01)))),IKFAST_ATAN2_MAGTHRESH);
if(!x230.valid){
continue;
}
IkReal x229=x230.value;
j1array[0]=((-1.0)*x229);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x229)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[1];
IkReal x231=IKsin(j1);
IkReal x232=IKcos(j1);
evalcond[0]=((((-1.63846153846154)*r00*x232))+(((-0.784615384615385)*r01*x232))+(((-1.63846153846154)*r01*x231))+(((0.784615384615385)*r00*x231)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1, j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x233=cj2*cj2;
IkReal x234=((0.213)*sj2);
IkReal x235=((0.13)*r01);
IkReal x236=(cj2*sj2);
IkReal x237=((0.213)*cj2);
IkReal x238=((0.13)*r00);
CheckValue<IkReal> x239=IKPowWithIntegerCheck(IKsign((((px*r01))+(((-1.0)*py*r00)))),-1);
if(!x239.valid){
continue;
}
CheckValue<IkReal> x240 = IKatan2WithCheck(IkReal((((x233*x235))+((r00*x237))+(((-1.0)*x235))+((r01*x234))+(((-1.0)*x236*x238)))),IkReal((((x233*x238))+((r00*x234))+(((-1.0)*x238))+((x235*x236))+(((-1.0)*r01*x237)))),IKFAST_ATAN2_MAGTHRESH);
if(!x240.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x239.value)))+(x240.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x241=IKcos(j1);
IkReal x242=IKsin(j1);
IkReal x243=(cj2*py);
IkReal x244=((1.0)*sj2);
IkReal x245=((1.0)*cj2);
IkReal x246=(px*x241);
IkReal x247=(r00*x241);
IkReal x248=(sj2*x241);
IkReal x249=(r00*x242);
IkReal x250=(px*x242);
IkReal x251=(r01*x242);
evalcond[0]=(((cj2*x251))+((r01*x248))+((cj2*x247))+(((-1.0)*x244*x249)));
evalcond[1]=((((-1.0)*x244*x251))+((cj2*r01*x241))+(((-1.0)*x245*x249))+(((-1.0)*x244*x247)));
evalcond[2]=((0.213)+(((-1.0)*x244*x250))+(((-0.13)*sj2))+((x242*x243))+((py*x248))+((cj2*x246)));
evalcond[3]=((-0.102)+(((-1.0)*x245*x250))+((x241*x243))+(((-0.13)*cj2))+(((-1.0)*py*x242*x244))+(((-1.0)*x244*x246)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x252=cj2*cj2;
IkReal x253=((0.13)*r01);
IkReal x254=(cj2*sj2);
IkReal x255=((0.102)*cj2);
IkReal x256=((0.13)*r00);
IkReal x257=((0.102)*sj2);
CheckValue<IkReal> x258=IKPowWithIntegerCheck(IKsign((((px*r01))+(((-1.0)*py*r00)))),-1);
if(!x258.valid){
continue;
}
CheckValue<IkReal> x259 = IKatan2WithCheck(IkReal(((((-1.0)*x252*x253))+((r00*x257))+(((-1.0)*r01*x255))+((x254*x256)))),IkReal(((((-1.0)*x252*x256))+(((-1.0)*r00*x255))+(((-1.0)*r01*x257))+(((-1.0)*x253*x254)))),IKFAST_ATAN2_MAGTHRESH);
if(!x259.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x258.value)))+(x259.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x260=IKcos(j1);
IkReal x261=IKsin(j1);
IkReal x262=(cj2*py);
IkReal x263=((1.0)*sj2);
IkReal x264=((1.0)*cj2);
IkReal x265=(px*x260);
IkReal x266=(r00*x260);
IkReal x267=(sj2*x260);
IkReal x268=(r00*x261);
IkReal x269=(px*x261);
IkReal x270=(r01*x261);
evalcond[0]=((((-1.0)*x263*x268))+((cj2*x270))+((r01*x267))+((cj2*x266)));
evalcond[1]=((((-1.0)*x263*x266))+(((-1.0)*x263*x270))+((cj2*r01*x260))+(((-1.0)*x264*x268)));
evalcond[2]=((0.213)+(((-1.0)*x263*x269))+(((-0.13)*sj2))+((x261*x262))+((py*x267))+((cj2*x265)));
evalcond[3]=((-0.102)+(((-1.0)*x263*x265))+(((-1.0)*py*x261*x263))+((x260*x262))+(((-0.13)*cj2))+(((-1.0)*x264*x269)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x271=cj2*cj2;
IkReal x272=((0.13)*r01);
IkReal x273=(cj2*sj2);
IkReal x274=((0.102)*cj2);
IkReal x275=((0.13)*r00);
IkReal x276=((0.102)*sj2);
CheckValue<IkReal> x277 = IKatan2WithCheck(IkReal(((((-1.0)*x272*x273))+(((-1.0)*x271*x275))+(((-1.0)*r01*x276))+(((-1.0)*r00*x274)))),IkReal(((((-1.0)*x273*x275))+((x271*x272))+(((-1.0)*r00*x276))+((r01*x274)))),IKFAST_ATAN2_MAGTHRESH);
if(!x277.valid){
continue;
}
CheckValue<IkReal> x278=IKPowWithIntegerCheck(IKsign((((px*r00))+((py*r01)))),-1);
if(!x278.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x277.value)+(((1.5707963267949)*(x278.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x279=IKcos(j1);
IkReal x280=IKsin(j1);
IkReal x281=(cj2*py);
IkReal x282=((1.0)*sj2);
IkReal x283=((1.0)*cj2);
IkReal x284=(px*x279);
IkReal x285=(r00*x279);
IkReal x286=(sj2*x279);
IkReal x287=(r00*x280);
IkReal x288=(px*x280);
IkReal x289=(r01*x280);
evalcond[0]=(((r01*x286))+((cj2*x285))+((cj2*x289))+(((-1.0)*x282*x287)));
evalcond[1]=((((-1.0)*x282*x285))+(((-1.0)*x282*x289))+((cj2*r01*x279))+(((-1.0)*x283*x287)));
evalcond[2]=((0.213)+((cj2*x284))+(((-1.0)*x282*x288))+(((-0.13)*sj2))+((x280*x281))+((py*x286)));
evalcond[3]=((-0.102)+(((-1.0)*py*x280*x282))+((x279*x281))+(((-1.0)*x282*x284))+(((-0.13)*cj2))+(((-1.0)*x283*x288)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1, j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x290=cj2*cj2;
IkReal x291=(cj4*sj2);
IkReal x292=((1.0)*px);
IkReal x293=(r01*sj2);
IkReal x294=((0.13)*cj2);
IkReal x295=(r00*sj2);
IkReal x296=(cj2*cj4);
IkReal x297=((0.102)*cj2);
IkReal x298=((0.13)*x290);
CheckValue<IkReal> x299 = IKatan2WithCheck(IkReal(((((0.102)*x293))+(((-1.0)*x291*x292))+((py*x296))+((r00*x297))+((r00*x298))+((x293*x294)))),IkReal(((((0.102)*x295))+((py*x291))+((px*x296))+((x294*x295))+(((-1.0)*r01*x297))+(((-1.0)*r01*x298)))),IKFAST_ATAN2_MAGTHRESH);
if(!x299.valid){
continue;
}
CheckValue<IkReal> x300=IKPowWithIntegerCheck(IKsign(((((-1.0)*r00*x292))+(((-1.0)*py*r01)))),-1);
if(!x300.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x299.value)+(((1.5707963267949)*(x300.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x301=IKcos(j1);
IkReal x302=IKsin(j1);
IkReal x303=(cj2*py);
IkReal x304=((1.0)*sj2);
IkReal x305=((1.0)*cj2);
IkReal x306=(px*x301);
IkReal x307=(r00*x301);
IkReal x308=(sj2*x301);
IkReal x309=(r00*x302);
IkReal x310=(px*x302);
IkReal x311=(r01*x302);
evalcond[0]=(cj4+((cj2*x307))+((cj2*x311))+(((-1.0)*x304*x309))+((r01*x308)));
evalcond[1]=(((cj2*r01*x301))+(((-1.0)*x304*x311))+(((-1.0)*x305*x309))+(((-1.0)*x304*x307)));
evalcond[2]=((-0.102)+((x301*x303))+(((-1.0)*x305*x310))+(((-1.0)*x304*x306))+(((-0.13)*cj2))+(((-1.0)*py*x302*x304)));
evalcond[3]=((0.213)+((cj2*x306))+(((-0.13)*sj2))+(((-1.0)*x304*x310))+((x302*x303))+((py*x308))+(((0.037)*cj4)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x312=cj2*cj2;
IkReal x313=((0.13)*r01);
IkReal x314=(cj2*sj2);
IkReal x315=((0.102)*cj2);
IkReal x316=((0.13)*r00);
IkReal x317=((0.102)*sj2);
CheckValue<IkReal> x318 = IKatan2WithCheck(IkReal(((((-1.0)*x312*x313))+(((-1.0)*r01*x315))+((r00*x317))+((x314*x316)))),IkReal(((((-1.0)*x313*x314))+(((-1.0)*x312*x316))+(((-1.0)*r01*x317))+(((-1.0)*r00*x315)))),IKFAST_ATAN2_MAGTHRESH);
if(!x318.valid){
continue;
}
CheckValue<IkReal> x319=IKPowWithIntegerCheck(IKsign((((px*r01))+(((-1.0)*py*r00)))),-1);
if(!x319.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x318.value)+(((1.5707963267949)*(x319.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x320=IKcos(j1);
IkReal x321=IKsin(j1);
IkReal x322=(cj2*py);
IkReal x323=((1.0)*sj2);
IkReal x324=((1.0)*cj2);
IkReal x325=(px*x320);
IkReal x326=(r00*x320);
IkReal x327=(sj2*x320);
IkReal x328=(r00*x321);
IkReal x329=(px*x321);
IkReal x330=(r01*x321);
evalcond[0]=(((cj2*x326))+cj4+((cj2*x330))+((r01*x327))+(((-1.0)*x323*x328)));
evalcond[1]=(((cj2*r01*x320))+(((-1.0)*x323*x326))+(((-1.0)*x323*x330))+(((-1.0)*x324*x328)));
evalcond[2]=((-0.102)+((x320*x322))+(((-1.0)*x323*x325))+(((-1.0)*py*x321*x323))+(((-0.13)*cj2))+(((-1.0)*x324*x329)));
evalcond[3]=((0.213)+((cj2*x325))+((py*x327))+(((-1.0)*x323*x329))+(((-0.13)*sj2))+((x321*x322))+(((0.037)*cj4)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x331=(cj4*r00);
IkReal x332=(cj4*r01);
CheckValue<IkReal> x333 = IKatan2WithCheck(IkReal((((cj2*x332))+(((-1.0)*sj2*x331)))),IkReal((((sj2*x332))+((cj2*x331)))),IKFAST_ATAN2_MAGTHRESH);
if(!x333.valid){
continue;
}
CheckValue<IkReal> x334=IKPowWithIntegerCheck(IKsign(((-1.0)+(r02*r02))),-1);
if(!x334.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x333.value)+(((1.5707963267949)*(x334.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x335=IKcos(j1);
IkReal x336=IKsin(j1);
IkReal x337=(cj2*py);
IkReal x338=((1.0)*sj2);
IkReal x339=((1.0)*cj2);
IkReal x340=(px*x335);
IkReal x341=(r00*x335);
IkReal x342=(sj2*x335);
IkReal x343=(r00*x336);
IkReal x344=(px*x336);
IkReal x345=(r01*x336);
evalcond[0]=(((r01*x342))+cj4+(((-1.0)*x338*x343))+((cj2*x345))+((cj2*x341)));
evalcond[1]=(((cj2*r01*x335))+(((-1.0)*x338*x345))+(((-1.0)*x338*x341))+(((-1.0)*x339*x343)));
evalcond[2]=((-0.102)+((x335*x337))+(((-1.0)*py*x336*x338))+(((-0.13)*cj2))+(((-1.0)*x338*x340))+(((-1.0)*x339*x344)));
evalcond[3]=((0.213)+((py*x342))+((x336*x337))+(((-0.13)*sj2))+(((-1.0)*x338*x344))+((cj2*x340))+(((0.037)*cj4)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
sj3=-1.0;
cj3=0;
j3=-1.5707963267949;
IkReal x346=((1.0)*cj4);
IkReal x347=((1.0)+(((-1.0)*(r02*r02))));
j1eval[0]=x347;
j1eval[1]=IKsign(x347);
j1eval[2]=((IKabs((((cj4*r00*sj2))+(((-1.0)*cj2*r01*x346)))))+(IKabs(((((-1.0)*r01*sj2*x346))+(((-1.0)*cj2*r00*x346))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
sj3=-1.0;
cj3=0;
j3=-1.5707963267949;
IkReal x348=cj2*cj2;
IkReal x349=((0.101)*r00);
IkReal x350=((0.13)*r01);
IkReal x351=(cj2*sj2);
IkReal x352=((0.13)*r00);
IkReal x353=((0.101)*r01);
IkReal x354=(((px*r01))+(((-1.0)*py*r00)));
j1eval[0]=x354;
j1eval[1]=((IKabs(((((-1.0)*cj2*x353))+((sj2*x349))+(((-1.0)*x348*x350))+((x351*x352)))))+(IKabs(((((-1.0)*sj2*x353))+(((-1.0)*x348*x352))+(((-1.0)*cj2*x349))+(((-1.0)*x350*x351))))));
j1eval[2]=IKsign(x354);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
sj3=-1.0;
cj3=0;
j3=-1.5707963267949;
IkReal x355=(((px*r00))+((py*r01)));
j1eval[0]=x355;
j1eval[1]=IKsign(x355);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
sj3=-1.0;
cj3=0;
j3=-1.5707963267949;
sj4=1.0;
cj4=0;
j4=1.5707963267949;
IkReal x356=cj2*cj2;
IkReal x357=((0.101)*r00);
IkReal x358=((0.13)*r01);
IkReal x359=(cj2*sj2);
IkReal x360=((0.13)*r00);
IkReal x361=((0.101)*r01);
IkReal x362=(((px*r01))+(((-1.0)*py*r00)));
j1eval[0]=x362;
j1eval[1]=((IKabs(((((-1.0)*x356*x358))+((x359*x360))+((sj2*x357))+(((-1.0)*cj2*x361)))))+(IKabs(((((-1.0)*cj2*x357))+(((-1.0)*x356*x360))+(((-1.0)*sj2*x361))+(((-1.0)*x358*x359))))));
j1eval[2]=IKsign(x362);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
sj3=-1.0;
cj3=0;
j3=-1.5707963267949;
sj4=1.0;
cj4=0;
j4=1.5707963267949;
IkReal x363=cj2*cj2;
IkReal x364=((0.101)*r00);
IkReal x365=((0.13)*r01);
IkReal x366=(cj2*sj2);
IkReal x367=((0.13)*r00);
IkReal x368=((0.101)*r01);
IkReal x369=((((-1.0)*px*r00))+(((-1.0)*py*r01)));
j1eval[0]=x369;
j1eval[1]=((IKabs(((((-1.0)*x363*x365))+((x366*x367))+((sj2*x364))+(((-1.0)*cj2*x368)))))+(IKabs((((x365*x366))+((sj2*x368))+((cj2*x364))+((x363*x367))))));
j1eval[2]=IKsign(x369);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
sj3=-1.0;
cj3=0;
j3=-1.5707963267949;
sj4=1.0;
cj4=0;
j4=1.5707963267949;
IkReal x370=cj2*cj2;
IkReal x371=((0.213)*sj2);
IkReal x372=((0.13)*r01);
IkReal x373=(cj2*sj2);
IkReal x374=((0.213)*cj2);
IkReal x375=((0.13)*r00);
IkReal x376=(((px*r00))+((py*r01)));
j1eval[0]=x376;
j1eval[1]=((IKabs((((x370*x375))+((r00*x371))+(((-1.0)*r01*x374))+(((-1.0)*x375))+((x372*x373)))))+(IKabs(((((-1.0)*x370*x372))+(((-1.0)*r00*x374))+(((-1.0)*r01*x371))+x372+((x373*x375))))));
j1eval[2]=IKsign(x376);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
sj3=-1.0;
cj3=0;
j3=-1.5707963267949;
sj4=1.0;
cj4=0;
j4=1.5707963267949;
px=0;
py=0;
pp=pz*pz;
j1eval[0]=((1.0)+(((-1.0)*(r02*r02))));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x378 = IKatan2WithCheck(IkReal(((((1.63846153846154)*r01))+(((-0.776923076923077)*r00)))),IkReal(((((-1.63846153846154)*r00))+(((-0.776923076923077)*r01)))),IKFAST_ATAN2_MAGTHRESH);
if(!x378.valid){
continue;
}
IkReal x377=x378.value;
j1array[0]=((-1.0)*x377);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x377)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[1];
IkReal x379=IKcos(j1);
IkReal x380=IKsin(j1);
evalcond[0]=((((1.63846153846154)*r00*x379))+(((0.776923076923077)*r01*x379))+(((-0.776923076923077)*r00*x380))+(((1.63846153846154)*r01*x380)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1, j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x381=cj2*cj2;
IkReal x382=((0.213)*sj2);
IkReal x383=((0.13)*r01);
IkReal x384=(cj2*sj2);
IkReal x385=((0.213)*cj2);
IkReal x386=((0.13)*r00);
CheckValue<IkReal> x387 = IKatan2WithCheck(IkReal((((x383*x384))+(((-1.0)*x386))+(((-1.0)*r01*x385))+((r00*x382))+((x381*x386)))),IkReal((((x384*x386))+(((-1.0)*x381*x383))+x383+(((-1.0)*r00*x385))+(((-1.0)*r01*x382)))),IKFAST_ATAN2_MAGTHRESH);
if(!x387.valid){
continue;
}
CheckValue<IkReal> x388=IKPowWithIntegerCheck(IKsign((((px*r00))+((py*r01)))),-1);
if(!x388.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x387.value)+(((1.5707963267949)*(x388.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x389=IKcos(j1);
IkReal x390=IKsin(j1);
IkReal x391=(r01*sj2);
IkReal x392=(r00*sj2);
IkReal x393=(cj2*x390);
IkReal x394=((1.0)*x390);
IkReal x395=(sj2*x389);
IkReal x396=(cj2*x389);
IkReal x397=((1.0)*x396);
evalcond[0]=(((r00*x396))+((r01*x393))+((x389*x391))+(((-1.0)*x392*x394)));
evalcond[1]=(((r00*x393))+(((-1.0)*r01*x397))+((x389*x392))+((x390*x391)));
evalcond[2]=((0.213)+((py*x395))+((py*x393))+((px*x396))+(((-0.13)*sj2))+(((-1.0)*px*sj2*x394)));
evalcond[3]=((0.101)+((py*sj2*x390))+((px*x395))+((px*x393))+(((-1.0)*py*x397))+(((0.13)*cj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x398=cj2*cj2;
IkReal x399=((0.101)*r00);
IkReal x400=((0.13)*r01);
IkReal x401=(cj2*sj2);
IkReal x402=((0.13)*r00);
IkReal x403=((0.101)*r01);
CheckValue<IkReal> x404=IKPowWithIntegerCheck(IKsign(((((-1.0)*px*r00))+(((-1.0)*py*r01)))),-1);
if(!x404.valid){
continue;
}
CheckValue<IkReal> x405 = IKatan2WithCheck(IkReal((((sj2*x403))+((cj2*x399))+((x398*x402))+((x400*x401)))),IkReal(((((-1.0)*cj2*x403))+((sj2*x399))+(((-1.0)*x398*x400))+((x401*x402)))),IKFAST_ATAN2_MAGTHRESH);
if(!x405.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x404.value)))+(x405.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x406=IKcos(j1);
IkReal x407=IKsin(j1);
IkReal x408=(r01*sj2);
IkReal x409=(r00*sj2);
IkReal x410=(cj2*x407);
IkReal x411=((1.0)*x407);
IkReal x412=(sj2*x406);
IkReal x413=(cj2*x406);
IkReal x414=((1.0)*x413);
evalcond[0]=(((r01*x410))+((x406*x408))+((r00*x413))+(((-1.0)*x409*x411)));
evalcond[1]=(((x407*x408))+((x406*x409))+((r00*x410))+(((-1.0)*r01*x414)));
evalcond[2]=((0.213)+((py*x412))+((py*x410))+((px*x413))+(((-1.0)*px*sj2*x411))+(((-0.13)*sj2)));
evalcond[3]=((0.101)+((px*x412))+((px*x410))+(((-1.0)*py*x414))+((py*sj2*x407))+(((0.13)*cj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x415=cj2*cj2;
IkReal x416=((0.101)*r00);
IkReal x417=((0.13)*r01);
IkReal x418=(cj2*sj2);
IkReal x419=((0.13)*r00);
IkReal x420=((0.101)*r01);
CheckValue<IkReal> x421=IKPowWithIntegerCheck(IKsign((((px*r01))+(((-1.0)*py*r00)))),-1);
if(!x421.valid){
continue;
}
CheckValue<IkReal> x422 = IKatan2WithCheck(IkReal(((((-1.0)*cj2*x420))+((sj2*x416))+(((-1.0)*x415*x417))+((x418*x419)))),IkReal(((((-1.0)*x417*x418))+(((-1.0)*sj2*x420))+(((-1.0)*cj2*x416))+(((-1.0)*x415*x419)))),IKFAST_ATAN2_MAGTHRESH);
if(!x422.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x421.value)))+(x422.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x423=IKcos(j1);
IkReal x424=IKsin(j1);
IkReal x425=(r01*sj2);
IkReal x426=(r00*sj2);
IkReal x427=(cj2*x424);
IkReal x428=((1.0)*x424);
IkReal x429=(sj2*x423);
IkReal x430=(cj2*x423);
IkReal x431=((1.0)*x430);
evalcond[0]=((((-1.0)*x426*x428))+((r01*x427))+((r00*x430))+((x423*x425)));
evalcond[1]=(((x424*x425))+((r00*x427))+((x423*x426))+(((-1.0)*r01*x431)));
evalcond[2]=((0.213)+((px*x430))+((py*x429))+((py*x427))+(((-0.13)*sj2))+(((-1.0)*px*sj2*x428)));
evalcond[3]=((0.101)+(((-1.0)*py*x431))+((py*sj2*x424))+(((0.13)*cj2))+((px*x429))+((px*x427)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
sj3=-1.0;
cj3=0;
j3=-1.5707963267949;
sj4=-1.0;
cj4=0;
j4=-1.5707963267949;
IkReal x432=cj2*cj2;
IkReal x433=((0.101)*r00);
IkReal x434=((0.13)*r01);
IkReal x435=(cj2*sj2);
IkReal x436=((0.13)*r00);
IkReal x437=((0.101)*r01);
IkReal x438=(((px*r01))+(((-1.0)*py*r00)));
j1eval[0]=x438;
j1eval[1]=((IKabs(((((-1.0)*cj2*x433))+(((-1.0)*x432*x436))+(((-1.0)*x434*x435))+(((-1.0)*sj2*x437)))))+(IKabs(((((-1.0)*cj2*x437))+(((-1.0)*x432*x434))+((sj2*x433))+((x435*x436))))));
j1eval[2]=IKsign(x438);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
sj3=-1.0;
cj3=0;
j3=-1.5707963267949;
sj4=-1.0;
cj4=0;
j4=-1.5707963267949;
IkReal x439=cj2*cj2;
IkReal x440=((0.101)*r00);
IkReal x441=((0.13)*r01);
IkReal x442=(cj2*sj2);
IkReal x443=((0.13)*r00);
IkReal x444=((0.101)*r01);
IkReal x445=((((-1.0)*px*r00))+(((-1.0)*py*r01)));
j1eval[0]=x445;
j1eval[1]=((IKabs((((x439*x443))+((x441*x442))+((cj2*x440))+((sj2*x444)))))+(IKabs(((((-1.0)*cj2*x444))+(((-1.0)*x439*x441))+((sj2*x440))+((x442*x443))))));
j1eval[2]=IKsign(x445);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
sj3=-1.0;
cj3=0;
j3=-1.5707963267949;
sj4=-1.0;
cj4=0;
j4=-1.5707963267949;
IkReal x446=cj2*cj2;
IkReal x447=((0.213)*sj2);
IkReal x448=((0.13)*r01);
IkReal x449=(cj2*sj2);
IkReal x450=((0.213)*cj2);
IkReal x451=((0.13)*r00);
IkReal x452=(((px*r00))+((py*r01)));
j1eval[0]=x452;
j1eval[1]=((IKabs(((((-1.0)*r01*x450))+(((-1.0)*x451))+((x446*x451))+((r00*x447))+((x448*x449)))))+(IKabs(((((-1.0)*r00*x450))+x448+((x449*x451))+(((-1.0)*r01*x447))+(((-1.0)*x446*x448))))));
j1eval[2]=IKsign(x452);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
sj3=-1.0;
cj3=0;
j3=-1.5707963267949;
sj4=-1.0;
cj4=0;
j4=-1.5707963267949;
px=0;
py=0;
pp=pz*pz;
j1eval[0]=((1.0)+(((-1.0)*(r02*r02))));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x454 = IKatan2WithCheck(IkReal(((((1.63846153846154)*r01))+(((-0.776923076923077)*r00)))),IkReal(((((-1.63846153846154)*r00))+(((-0.776923076923077)*r01)))),IKFAST_ATAN2_MAGTHRESH);
if(!x454.valid){
continue;
}
IkReal x453=x454.value;
j1array[0]=((-1.0)*x453);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x453)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[1];
IkReal x455=IKcos(j1);
IkReal x456=IKsin(j1);
evalcond[0]=((((-0.776923076923077)*r00*x456))+(((1.63846153846154)*r00*x455))+(((1.63846153846154)*r01*x456))+(((0.776923076923077)*r01*x455)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1, j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x457=cj2*cj2;
IkReal x458=((0.213)*sj2);
IkReal x459=((0.13)*r01);
IkReal x460=(cj2*sj2);
IkReal x461=((0.213)*cj2);
IkReal x462=((0.13)*r00);
CheckValue<IkReal> x463 = IKatan2WithCheck(IkReal(((((-1.0)*r01*x461))+(((-1.0)*x462))+((r00*x458))+((x459*x460))+((x457*x462)))),IkReal(((((-1.0)*r01*x458))+(((-1.0)*r00*x461))+x459+((x460*x462))+(((-1.0)*x457*x459)))),IKFAST_ATAN2_MAGTHRESH);
if(!x463.valid){
continue;
}
CheckValue<IkReal> x464=IKPowWithIntegerCheck(IKsign((((px*r00))+((py*r01)))),-1);
if(!x464.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x463.value)+(((1.5707963267949)*(x464.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x465=IKcos(j1);
IkReal x466=IKsin(j1);
IkReal x467=(r01*sj2);
IkReal x468=(r00*sj2);
IkReal x469=(cj2*x466);
IkReal x470=((1.0)*x466);
IkReal x471=(sj2*x465);
IkReal x472=(cj2*x465);
IkReal x473=((1.0)*x472);
evalcond[0]=((((-1.0)*x468*x470))+((x465*x467))+((r01*x469))+((r00*x472)));
evalcond[1]=(((x465*x468))+((x466*x467))+(((-1.0)*r01*x473))+((r00*x469)));
evalcond[2]=((0.213)+(((-0.13)*sj2))+((py*x471))+(((-1.0)*px*sj2*x470))+((py*x469))+((px*x472)));
evalcond[3]=((0.101)+(((-1.0)*py*x473))+((py*sj2*x466))+((px*x469))+((px*x471))+(((0.13)*cj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x474=cj2*cj2;
IkReal x475=((0.101)*r00);
IkReal x476=((0.13)*r01);
IkReal x477=(cj2*sj2);
IkReal x478=((0.13)*r00);
IkReal x479=((0.101)*r01);
CheckValue<IkReal> x480=IKPowWithIntegerCheck(IKsign(((((-1.0)*px*r00))+(((-1.0)*py*r01)))),-1);
if(!x480.valid){
continue;
}
CheckValue<IkReal> x481 = IKatan2WithCheck(IkReal((((cj2*x475))+((x474*x478))+((x476*x477))+((sj2*x479)))),IkReal((((x477*x478))+(((-1.0)*cj2*x479))+(((-1.0)*x474*x476))+((sj2*x475)))),IKFAST_ATAN2_MAGTHRESH);
if(!x481.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x480.value)))+(x481.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x482=IKcos(j1);
IkReal x483=IKsin(j1);
IkReal x484=(r01*sj2);
IkReal x485=(r00*sj2);
IkReal x486=(cj2*x483);
IkReal x487=((1.0)*x483);
IkReal x488=(sj2*x482);
IkReal x489=(cj2*x482);
IkReal x490=((1.0)*x489);
evalcond[0]=(((r01*x486))+((r00*x489))+((x482*x484))+(((-1.0)*x485*x487)));
evalcond[1]=((((-1.0)*r01*x490))+((x483*x484))+((r00*x486))+((x482*x485)));
evalcond[2]=((0.213)+(((-1.0)*px*sj2*x487))+((py*x488))+((py*x486))+((px*x489))+(((-0.13)*sj2)));
evalcond[3]=((0.101)+((px*x488))+((px*x486))+((py*sj2*x483))+(((-1.0)*py*x490))+(((0.13)*cj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x491=cj2*cj2;
IkReal x492=((0.101)*r00);
IkReal x493=((0.13)*r01);
IkReal x494=(cj2*sj2);
IkReal x495=((0.13)*r00);
IkReal x496=((0.101)*r01);
CheckValue<IkReal> x497=IKPowWithIntegerCheck(IKsign((((px*r01))+(((-1.0)*py*r00)))),-1);
if(!x497.valid){
continue;
}
CheckValue<IkReal> x498 = IKatan2WithCheck(IkReal(((((-1.0)*x491*x493))+(((-1.0)*cj2*x496))+((x494*x495))+((sj2*x492)))),IkReal(((((-1.0)*sj2*x496))+(((-1.0)*x491*x495))+(((-1.0)*cj2*x492))+(((-1.0)*x493*x494)))),IKFAST_ATAN2_MAGTHRESH);
if(!x498.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x497.value)))+(x498.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x499=IKcos(j1);
IkReal x500=IKsin(j1);
IkReal x501=(r01*sj2);
IkReal x502=(r00*sj2);
IkReal x503=(cj2*x500);
IkReal x504=((1.0)*x500);
IkReal x505=(sj2*x499);
IkReal x506=(cj2*x499);
IkReal x507=((1.0)*x506);
evalcond[0]=((((-1.0)*x502*x504))+((r01*x503))+((r00*x506))+((x499*x501)));
evalcond[1]=(((x500*x501))+(((-1.0)*r01*x507))+((r00*x503))+((x499*x502)));
evalcond[2]=((0.213)+(((-1.0)*px*sj2*x504))+(((-0.13)*sj2))+((px*x506))+((py*x503))+((py*x505)));
evalcond[3]=((0.101)+((py*sj2*x500))+(((-1.0)*py*x507))+((px*x503))+((px*x505))+(((0.13)*cj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1, j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x508=cj2*cj2;
IkReal x509=((0.101)*r00);
IkReal x510=(cj4*px);
IkReal x511=((1.0)*cj2);
IkReal x512=((0.13)*r01);
IkReal x513=(cj2*sj2);
IkReal x514=((0.13)*r00);
IkReal x515=((0.101)*r01);
IkReal x516=(cj4*py);
CheckValue<IkReal> x517=IKPowWithIntegerCheck(IKsign((((px*r00))+((py*r01)))),-1);
if(!x517.valid){
continue;
}
CheckValue<IkReal> x518 = IKatan2WithCheck(IkReal(((((-1.0)*x511*x516))+(((-1.0)*sj2*x515))+(((-1.0)*x512*x513))+(((-1.0)*cj2*x509))+((sj2*x510))+(((-1.0)*x508*x514)))),IkReal(((((-1.0)*sj2*x516))+(((-1.0)*sj2*x509))+(((-1.0)*x513*x514))+((cj2*x515))+((x508*x512))+(((-1.0)*x510*x511)))),IKFAST_ATAN2_MAGTHRESH);
if(!x518.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x517.value)))+(x518.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x519=IKsin(j1);
IkReal x520=IKcos(j1);
IkReal x521=((1.0)*cj2);
IkReal x522=(r01*x520);
IkReal x523=(sj2*x519);
IkReal x524=(cj2*x519);
IkReal x525=(sj2*x520);
IkReal x526=(cj2*x520);
evalcond[0]=((((-1.0)*x521*x522))+((r01*x523))+((r00*x525))+((r00*x524)));
evalcond[1]=(cj4+((sj2*x522))+((r01*x524))+(((-1.0)*r00*x523))+((r00*x526)));
evalcond[2]=((0.101)+((px*x525))+((px*x524))+(((-1.0)*py*x520*x521))+(((0.13)*cj2))+((py*x523)));
evalcond[3]=((0.213)+((px*x526))+(((-0.13)*sj2))+(((-1.0)*px*x523))+((py*x525))+((py*x524))+(((0.037)*cj4)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x527=cj2*cj2;
IkReal x528=((0.101)*r00);
IkReal x529=((0.13)*r01);
IkReal x530=(cj2*sj2);
IkReal x531=((0.13)*r00);
IkReal x532=((0.101)*r01);
CheckValue<IkReal> x533=IKPowWithIntegerCheck(IKsign((((px*r01))+(((-1.0)*py*r00)))),-1);
if(!x533.valid){
continue;
}
CheckValue<IkReal> x534 = IKatan2WithCheck(IkReal(((((-1.0)*cj2*x532))+(((-1.0)*x527*x529))+((sj2*x528))+((x530*x531)))),IkReal(((((-1.0)*cj2*x528))+(((-1.0)*sj2*x532))+(((-1.0)*x527*x531))+(((-1.0)*x529*x530)))),IKFAST_ATAN2_MAGTHRESH);
if(!x534.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x533.value)))+(x534.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x535=IKsin(j1);
IkReal x536=IKcos(j1);
IkReal x537=((1.0)*cj2);
IkReal x538=(r01*x536);
IkReal x539=(sj2*x535);
IkReal x540=(cj2*x535);
IkReal x541=(sj2*x536);
IkReal x542=(cj2*x536);
evalcond[0]=((((-1.0)*x537*x538))+((r00*x541))+((r00*x540))+((r01*x539)));
evalcond[1]=(cj4+((sj2*x538))+(((-1.0)*r00*x539))+((r00*x542))+((r01*x540)));
evalcond[2]=((0.101)+((px*x541))+((px*x540))+(((-1.0)*py*x536*x537))+(((0.13)*cj2))+((py*x539)));
evalcond[3]=((0.213)+((py*x540))+((py*x541))+((px*x542))+(((-0.13)*sj2))+(((-1.0)*px*x539))+(((0.037)*cj4)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x543=(cj4*sj2);
IkReal x544=((1.0)*r01);
IkReal x545=(cj2*cj4);
CheckValue<IkReal> x546=IKPowWithIntegerCheck(IKsign(((1.0)+(((-1.0)*(r02*r02))))),-1);
if(!x546.valid){
continue;
}
CheckValue<IkReal> x547 = IKatan2WithCheck(IkReal(((((-1.0)*x544*x545))+((r00*x543)))),IkReal(((((-1.0)*x543*x544))+(((-1.0)*r00*x545)))),IKFAST_ATAN2_MAGTHRESH);
if(!x547.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x546.value)))+(x547.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x548=IKsin(j1);
IkReal x549=IKcos(j1);
IkReal x550=((1.0)*cj2);
IkReal x551=(r01*x549);
IkReal x552=(sj2*x548);
IkReal x553=(cj2*x548);
IkReal x554=(sj2*x549);
IkReal x555=(cj2*x549);
evalcond[0]=((((-1.0)*x550*x551))+((r01*x552))+((r00*x554))+((r00*x553)));
evalcond[1]=(cj4+((sj2*x551))+(((-1.0)*r00*x552))+((r01*x553))+((r00*x555)));
evalcond[2]=((0.101)+((py*x552))+(((-1.0)*py*x549*x550))+((px*x553))+((px*x554))+(((0.13)*cj2)));
evalcond[3]=((0.213)+(((-1.0)*px*x552))+((py*x553))+((py*x554))+((px*x555))+(((-0.13)*sj2))+(((0.037)*cj4)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
evalcond[1]=r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
sj3=0;
cj3=1.0;
j3=0;
IkReal x556=(cj2*r00);
IkReal x557=((1.0)*sj4);
IkReal x558=(r01*sj2);
IkReal x559=(cj2*r01);
IkReal x560=(r00*sj2);
IkReal x561=((-1.0)+(r02*r02));
j1eval[0]=x561;
j1eval[1]=IKsign(x561);
j1eval[2]=((IKabs((((sj4*x559))+((cj4*x556))+((cj4*x558))+(((-1.0)*x557*x560)))))+(IKabs(((((-1.0)*x556*x557))+((cj4*x559))+(((-1.0)*cj4*x560))+(((-1.0)*x557*x558))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
sj3=0;
cj3=1.0;
j3=0;
IkReal x562=((((-1.0)*px*r00))+(((-1.0)*py*r01)));
j1eval[0]=x562;
j1eval[1]=IKsign(x562);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
sj3=0;
cj3=1.0;
j3=0;
IkReal x563=((((-1.0)*px*r01))+((py*r00)));
j1eval[0]=x563;
j1eval[1]=IKsign(x563);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
sj3=0;
cj3=1.0;
j3=0;
px=0;
py=0;
pp=pz*pz;
IkReal x564=(cj2*r00);
IkReal x565=((1.0)*sj4);
IkReal x566=(r01*sj2);
IkReal x567=(cj2*r01);
IkReal x568=(r00*sj2);
IkReal x569=((-1.0)+(r02*r02));
j1eval[0]=x569;
j1eval[1]=IKsign(x569);
j1eval[2]=((IKabs((((sj4*x567))+((cj4*x566))+((cj4*x564))+(((-1.0)*x565*x568)))))+(IKabs(((((-1.0)*x564*x565))+(((-1.0)*cj4*x568))+((cj4*x567))+(((-1.0)*x565*x566))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j1, j5]

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x570=(cj2*r00);
IkReal x571=((1.0)*sj4);
IkReal x572=(r01*sj2);
IkReal x573=(cj2*r01);
IkReal x574=(r00*sj2);
CheckValue<IkReal> x575 = IKatan2WithCheck(IkReal(((((-1.0)*x570*x571))+(((-1.0)*x571*x572))+(((-1.0)*cj4*x574))+((cj4*x573)))),IkReal((((sj4*x573))+(((-1.0)*x571*x574))+((cj4*x572))+((cj4*x570)))),IKFAST_ATAN2_MAGTHRESH);
if(!x575.valid){
continue;
}
CheckValue<IkReal> x576=IKPowWithIntegerCheck(IKsign(((-1.0)+(r02*r02))),-1);
if(!x576.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x575.value)+(((1.5707963267949)*(x576.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[2];
IkReal x577=IKcos(j1);
IkReal x578=IKsin(j1);
IkReal x579=((1.0)*r00);
IkReal x580=(sj2*x577);
IkReal x581=(sj2*x578);
IkReal x582=(cj2*x578);
IkReal x583=(cj2*x577);
evalcond[0]=(cj4+(((-1.0)*x579*x581))+((r01*x582))+((r01*x580))+((r00*x583)));
evalcond[1]=(sj4+(((-1.0)*x579*x580))+(((-1.0)*x579*x582))+((r01*x583))+(((-1.0)*r01*x581)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1, j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x584=cj2*cj2;
IkReal x585=((0.213)*sj2);
IkReal x586=(r01*sj2);
IkReal x587=((0.13)*cj2);
IkReal x588=((0.213)*cj2);
IkReal x589=((0.037)*cj4);
IkReal x590=(cj4*sj2);
IkReal x591=(r00*sj2);
IkReal x592=(cj2*cj4);
IkReal x593=((0.13)*x584);
CheckValue<IkReal> x594=IKPowWithIntegerCheck(IKsign(((((-1.0)*px*r01))+((py*r00)))),-1);
if(!x594.valid){
continue;
}
CheckValue<IkReal> x595 = IKatan2WithCheck(IkReal(((((-1.0)*r01*x593))+(((0.13)*r01))+((py*x590))+(((-1.0)*x586*x589))+(((-1.0)*cj2*r00*x589))+((px*x592))+(((-1.0)*r01*x585))+(((-1.0)*r00*x588))+((x587*x591)))),IkReal(((((-1.0)*r00*x593))+(((0.13)*r00))+(((-1.0)*x589*x591))+(((-1.0)*x586*x587))+((cj2*r01*x589))+((r01*x588))+((px*x590))+(((-1.0)*r00*x585))+(((-1.0)*py*x592)))),IKFAST_ATAN2_MAGTHRESH);
if(!x595.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x594.value)))+(x595.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x596=IKcos(j1);
IkReal x597=IKsin(j1);
IkReal x598=(cj2*py);
IkReal x599=((1.0)*sj2);
IkReal x600=((1.0)*cj2);
IkReal x601=(px*x596);
IkReal x602=(px*x597);
IkReal x603=(r00*x596);
IkReal x604=(sj2*x596);
IkReal x605=(r00*x597);
IkReal x606=(r01*x597);
evalcond[0]=(cj4+((cj2*x606))+((cj2*x603))+(((-1.0)*x599*x605))+((r01*x604)));
evalcond[1]=(sj4+(((-1.0)*x599*x603))+(((-1.0)*x599*x606))+(((-1.0)*x600*x605))+((cj2*r01*x596)));
evalcond[2]=((0.213)+((cj2*x601))+(((-1.0)*x599*x602))+(((-0.13)*sj2))+((py*x604))+((x597*x598))+(((0.037)*cj4)));
evalcond[3]=((-0.1015)+(((-1.0)*py*x597*x599))+(((-1.0)*x599*x601))+(((-1.0)*x600*x602))+(((0.037)*sj4))+((x596*x598))+(((-0.13)*cj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x607=cj2*cj2;
IkReal x608=(r01*sj2);
IkReal x609=((0.037)*sj4);
IkReal x610=(r00*sj2);
IkReal x611=((1.0)*px);
IkReal x612=(cj4*sj2);
IkReal x613=((0.13)*cj2);
IkReal x614=((0.1015)*cj2);
IkReal x615=(cj2*cj4);
IkReal x616=((0.13)*x607);
CheckValue<IkReal> x617 = IKatan2WithCheck(IkReal((((r00*x616))+((r00*x614))+(((0.1015)*x608))+((x608*x613))+(((-1.0)*x608*x609))+(((-1.0)*x611*x612))+(((-1.0)*cj2*r00*x609))+((py*x615)))),IkReal(((((0.1015)*x610))+(((-1.0)*x609*x610))+(((-1.0)*r01*x614))+(((-1.0)*r01*x616))+((px*x615))+((cj2*r01*x609))+((py*x612))+((x610*x613)))),IKFAST_ATAN2_MAGTHRESH);
if(!x617.valid){
continue;
}
CheckValue<IkReal> x618=IKPowWithIntegerCheck(IKsign(((((-1.0)*r00*x611))+(((-1.0)*py*r01)))),-1);
if(!x618.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x617.value)+(((1.5707963267949)*(x618.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x619=IKcos(j1);
IkReal x620=IKsin(j1);
IkReal x621=(cj2*py);
IkReal x622=((1.0)*sj2);
IkReal x623=((1.0)*cj2);
IkReal x624=(px*x619);
IkReal x625=(px*x620);
IkReal x626=(r00*x619);
IkReal x627=(sj2*x619);
IkReal x628=(r00*x620);
IkReal x629=(r01*x620);
evalcond[0]=(cj4+(((-1.0)*x622*x628))+((r01*x627))+((cj2*x626))+((cj2*x629)));
evalcond[1]=(sj4+(((-1.0)*x623*x628))+(((-1.0)*x622*x626))+(((-1.0)*x622*x629))+((cj2*r01*x619)));
evalcond[2]=((0.213)+((py*x627))+(((-1.0)*x622*x625))+(((-0.13)*sj2))+((cj2*x624))+(((0.037)*cj4))+((x620*x621)));
evalcond[3]=((-0.1015)+(((-1.0)*x623*x625))+((x619*x621))+(((-1.0)*x622*x624))+(((-1.0)*py*x620*x622))+(((0.037)*sj4))+(((-0.13)*cj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x630=(cj2*r00);
IkReal x631=((1.0)*sj4);
IkReal x632=(r01*sj2);
IkReal x633=(cj2*r01);
IkReal x634=(r00*sj2);
CheckValue<IkReal> x635 = IKatan2WithCheck(IkReal(((((-1.0)*cj4*x634))+(((-1.0)*x631*x632))+(((-1.0)*x630*x631))+((cj4*x633)))),IkReal((((sj4*x633))+(((-1.0)*x631*x634))+((cj4*x630))+((cj4*x632)))),IKFAST_ATAN2_MAGTHRESH);
if(!x635.valid){
continue;
}
CheckValue<IkReal> x636=IKPowWithIntegerCheck(IKsign(((-1.0)+(r02*r02))),-1);
if(!x636.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x635.value)+(((1.5707963267949)*(x636.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x637=IKcos(j1);
IkReal x638=IKsin(j1);
IkReal x639=(cj2*py);
IkReal x640=((1.0)*sj2);
IkReal x641=((1.0)*cj2);
IkReal x642=(px*x637);
IkReal x643=(px*x638);
IkReal x644=(r00*x637);
IkReal x645=(sj2*x637);
IkReal x646=(r00*x638);
IkReal x647=(r01*x638);
evalcond[0]=(cj4+(((-1.0)*x640*x646))+((cj2*x644))+((cj2*x647))+((r01*x645)));
evalcond[1]=(((cj2*r01*x637))+sj4+(((-1.0)*x640*x644))+(((-1.0)*x640*x647))+(((-1.0)*x641*x646)));
evalcond[2]=((0.213)+(((-1.0)*x640*x643))+((x638*x639))+((py*x645))+(((-0.13)*sj2))+((cj2*x642))+(((0.037)*cj4)));
evalcond[3]=((-0.1015)+(((-1.0)*x640*x642))+(((-1.0)*x641*x643))+(((-1.0)*py*x638*x640))+(((0.037)*sj4))+(((-0.13)*cj2))+((x637*x639)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
IkReal x648=(r00*sj2);
IkReal x649=(cj2*r01);
IkReal x650=((1.0)*cj4);
IkReal x651=((1.0)*sj4);
IkReal x652=(r01*sj2);
IkReal x653=(cj2*r00);
IkReal x654=((1.0)+(((-1.0)*(r02*r02))));
j1eval[0]=x654;
j1eval[1]=IKsign(x654);
j1eval[2]=((IKabs((((sj4*x649))+(((-1.0)*x650*x653))+(((-1.0)*x650*x652))+(((-1.0)*x648*x651)))))+(IKabs(((((-1.0)*x651*x653))+(((-1.0)*x651*x652))+((cj4*x648))+(((-1.0)*x649*x650))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
IkReal x655=(((px*r00))+((py*r01)));
j1eval[0]=x655;
j1eval[1]=IKsign(x655);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
IkReal x656=((((-1.0)*px*r01))+((py*r00)));
j1eval[0]=x656;
j1eval[1]=IKsign(x656);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
px=0;
py=0;
pp=pz*pz;
IkReal x657=(r00*sj2);
IkReal x658=(cj2*r01);
IkReal x659=((1.0)*cj4);
IkReal x660=((1.0)*sj4);
IkReal x661=(r01*sj2);
IkReal x662=(cj2*r00);
IkReal x663=((1.0)+(((-1.0)*(r02*r02))));
j1eval[0]=x663;
j1eval[1]=IKsign(x663);
j1eval[2]=((IKabs((((sj4*x658))+(((-1.0)*x659*x662))+(((-1.0)*x659*x661))+(((-1.0)*x657*x660)))))+(IKabs((((cj4*x657))+(((-1.0)*x660*x662))+(((-1.0)*x660*x661))+(((-1.0)*x658*x659))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j1, j5]

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x664=(r00*sj2);
IkReal x665=(cj2*r01);
IkReal x666=((1.0)*cj4);
IkReal x667=((1.0)*sj4);
IkReal x668=(r01*sj2);
IkReal x669=(cj2*r00);
CheckValue<IkReal> x670=IKPowWithIntegerCheck(IKsign(((1.0)+(((-1.0)*(r02*r02))))),-1);
if(!x670.valid){
continue;
}
CheckValue<IkReal> x671 = IKatan2WithCheck(IkReal(((((-1.0)*x665*x666))+(((-1.0)*x667*x669))+(((-1.0)*x667*x668))+((cj4*x664)))),IkReal((((sj4*x665))+(((-1.0)*x666*x668))+(((-1.0)*x666*x669))+(((-1.0)*x664*x667)))),IKFAST_ATAN2_MAGTHRESH);
if(!x671.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x670.value)))+(x671.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[2];
IkReal x672=IKcos(j1);
IkReal x673=IKsin(j1);
IkReal x674=(r01*sj2);
IkReal x675=(cj2*r01);
IkReal x676=(r00*x673);
IkReal x677=(r00*x672);
evalcond[0]=(((x673*x675))+((cj2*x677))+((x672*x674))+(((-1.0)*sj2*x676))+cj4);
evalcond[1]=(((x673*x674))+((cj2*x676))+sj4+((sj2*x677))+(((-1.0)*x672*x675)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1, j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x678=cj2*cj2;
IkReal x679=((0.213)*sj2);
IkReal x680=(r01*sj2);
IkReal x681=((0.13)*cj2);
IkReal x682=((0.213)*cj2);
IkReal x683=((0.037)*cj4);
IkReal x684=(cj4*sj2);
IkReal x685=(r00*sj2);
IkReal x686=(cj2*cj4);
IkReal x687=((0.13)*x678);
CheckValue<IkReal> x688=IKPowWithIntegerCheck(IKsign(((((-1.0)*px*r01))+((py*r00)))),-1);
if(!x688.valid){
continue;
}
CheckValue<IkReal> x689 = IKatan2WithCheck(IkReal((((px*x686))+(((-1.0)*x680*x683))+(((0.13)*r01))+(((-1.0)*r01*x687))+(((-1.0)*r00*x682))+(((-1.0)*cj2*r00*x683))+((x681*x685))+(((-1.0)*r01*x679))+((py*x684)))),IkReal((((px*x684))+(((-1.0)*py*x686))+(((-1.0)*x680*x681))+(((0.13)*r00))+(((-1.0)*r00*x687))+((r01*x682))+(((-1.0)*x683*x685))+(((-1.0)*r00*x679))+((cj2*r01*x683)))),IKFAST_ATAN2_MAGTHRESH);
if(!x689.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x688.value)))+(x689.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x690=IKcos(j1);
IkReal x691=IKsin(j1);
IkReal x692=(cj2*x691);
IkReal x693=(sj2*x691);
IkReal x694=(sj2*x690);
IkReal x695=(cj2*x690);
IkReal x696=((1.0)*x695);
evalcond[0]=(cj4+((r00*x695))+(((-1.0)*r00*x693))+((r01*x692))+((r01*x694)));
evalcond[1]=((((-1.0)*r01*x696))+sj4+((r00*x694))+((r00*x692))+((r01*x693)));
evalcond[2]=((0.213)+(((-1.0)*px*x693))+((py*x692))+((py*x694))+((px*x695))+(((-0.13)*sj2))+(((0.037)*cj4)));
evalcond[3]=((0.1015)+((py*x693))+((px*x694))+((px*x692))+(((0.037)*sj4))+(((-1.0)*py*x696))+(((0.13)*cj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x697=cj2*cj2;
IkReal x698=(r01*sj2);
IkReal x699=((0.037)*sj4);
IkReal x700=(cj4*px);
IkReal x701=((1.0)*cj2);
IkReal x702=(r00*sj2);
IkReal x703=((0.13)*cj2);
IkReal x704=(cj2*r01);
IkReal x705=(cj4*py);
IkReal x706=(cj2*r00);
IkReal x707=((0.13)*x697);
CheckValue<IkReal> x708 = IKatan2WithCheck(IkReal(((((-0.1015)*x698))+((sj2*x700))+(((-1.0)*x699*x706))+(((-1.0)*x698*x699))+(((-1.0)*x698*x703))+(((-1.0)*r00*x707))+(((-0.1015)*x706))+(((-1.0)*x701*x705)))),IkReal(((((-1.0)*x702*x703))+((r01*x707))+(((0.1015)*x704))+(((-1.0)*sj2*x705))+(((-1.0)*x699*x702))+(((-0.1015)*x702))+((x699*x704))+(((-1.0)*x700*x701)))),IKFAST_ATAN2_MAGTHRESH);
if(!x708.valid){
continue;
}
CheckValue<IkReal> x709=IKPowWithIntegerCheck(IKsign((((px*r00))+((py*r01)))),-1);
if(!x709.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x708.value)+(((1.5707963267949)*(x709.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x710=IKcos(j1);
IkReal x711=IKsin(j1);
IkReal x712=(cj2*x711);
IkReal x713=(sj2*x711);
IkReal x714=(sj2*x710);
IkReal x715=(cj2*x710);
IkReal x716=((1.0)*x715);
evalcond[0]=(cj4+(((-1.0)*r00*x713))+((r01*x712))+((r01*x714))+((r00*x715)));
evalcond[1]=(sj4+((r01*x713))+((r00*x714))+((r00*x712))+(((-1.0)*r01*x716)));
evalcond[2]=((0.213)+(((-1.0)*px*x713))+((px*x715))+(((-0.13)*sj2))+((py*x712))+((py*x714))+(((0.037)*cj4)));
evalcond[3]=((0.1015)+((px*x714))+((px*x712))+(((0.037)*sj4))+((py*x713))+(((0.13)*cj2))+(((-1.0)*py*x716)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x717=(r00*sj2);
IkReal x718=(cj2*r01);
IkReal x719=((1.0)*cj4);
IkReal x720=((1.0)*sj4);
IkReal x721=(r01*sj2);
IkReal x722=(cj2*r00);
CheckValue<IkReal> x723=IKPowWithIntegerCheck(IKsign(((1.0)+(((-1.0)*(r02*r02))))),-1);
if(!x723.valid){
continue;
}
CheckValue<IkReal> x724 = IKatan2WithCheck(IkReal((((cj4*x717))+(((-1.0)*x720*x722))+(((-1.0)*x720*x721))+(((-1.0)*x718*x719)))),IkReal((((sj4*x718))+(((-1.0)*x717*x720))+(((-1.0)*x719*x722))+(((-1.0)*x719*x721)))),IKFAST_ATAN2_MAGTHRESH);
if(!x724.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x723.value)))+(x724.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[4];
IkReal x725=IKcos(j1);
IkReal x726=IKsin(j1);
IkReal x727=(cj2*x726);
IkReal x728=(sj2*x726);
IkReal x729=(sj2*x725);
IkReal x730=(cj2*x725);
IkReal x731=((1.0)*x730);
evalcond[0]=(cj4+((r01*x727))+((r01*x729))+((r00*x730))+(((-1.0)*r00*x728)));
evalcond[1]=((((-1.0)*r01*x731))+sj4+((r01*x728))+((r00*x729))+((r00*x727)));
evalcond[2]=((0.213)+(((-0.13)*sj2))+((px*x730))+((py*x727))+((py*x729))+(((-1.0)*px*x728))+(((0.037)*cj4)));
evalcond[3]=((0.1015)+(((0.037)*sj4))+((py*x728))+((px*x729))+((px*x727))+(((-1.0)*py*x731))+(((0.13)*cj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1, j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x732=cj2*cj2;
IkReal x733=((0.213)*sj2);
IkReal x734=(r01*sj2);
IkReal x735=((0.13)*cj2);
IkReal x736=((0.213)*cj2);
IkReal x737=((0.037)*cj4);
IkReal x738=(cj4*sj2);
IkReal x739=(r00*sj2);
IkReal x740=(cj2*cj4);
IkReal x741=((0.13)*x732);
CheckValue<IkReal> x742=IKPowWithIntegerCheck(IKsign(((((-1.0)*px*r01))+((py*r00)))),-1);
if(!x742.valid){
continue;
}
CheckValue<IkReal> x743 = IKatan2WithCheck(IkReal(((((-1.0)*r01*x733))+(((0.13)*r01))+((x735*x739))+(((-1.0)*x734*x737))+((px*x740))+(((-1.0)*cj2*r00*x737))+(((-1.0)*r01*x741))+((py*x738))+(((-1.0)*r00*x736)))),IkReal(((((-1.0)*py*x740))+(((0.13)*r00))+(((-1.0)*x734*x735))+((r01*x736))+(((-1.0)*x737*x739))+((cj2*r01*x737))+(((-1.0)*r00*x741))+((px*x738))+(((-1.0)*r00*x733)))),IKFAST_ATAN2_MAGTHRESH);
if(!x743.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x742.value)))+(x743.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x744=IKcos(j1);
IkReal x745=IKsin(j1);
IkReal x746=(r01*sj3);
IkReal x747=(cj2*px);
IkReal x748=((1.0)*sj3);
IkReal x749=((1.0)*cj3);
IkReal x750=(cj3*sj2);
IkReal x751=((0.13)*cj2);
IkReal x752=(py*sj3);
IkReal x753=(cj2*r00);
IkReal x754=((1.0)*x745);
IkReal x755=(cj2*x744);
IkReal x756=(sj2*x744);
IkReal x757=(cj2*x745);
IkReal x758=(r00*x756);
evalcond[0]=(cj4+((x744*x753))+(((-1.0)*r00*sj2*x754))+((r01*x756))+((r01*x757)));
evalcond[1]=((0.213)+((py*x756))+((py*x757))+((x744*x747))+(((-0.13)*sj2))+(((-1.0)*px*sj2*x754))+(((0.037)*cj4)));
evalcond[2]=((((-1.0)*x745*x748*x753))+(((-1.0)*sj2*x746*x754))+((x746*x755))+((cj3*r02))+(((-1.0)*x748*x758)));
evalcond[3]=(sj4+(((-1.0)*x745*x749*x753))+((cj3*r01*x755))+(((-1.0)*r01*sj2*x745*x749))+(((-1.0)*r02*x748))+(((-1.0)*x749*x758)));
evalcond[4]=((-0.0005)+(((-0.1015)*sj3))+(((-1.0)*x745*x747*x748))+(((-0.0135)*cj3))+(((-1.0)*sj3*x751))+((x752*x755))+((cj3*pz))+(((-1.0)*py*sj2*x745*x748))+(((-1.0)*px*x748*x756)));
evalcond[5]=((((-1.0)*x745*x747*x749))+(((-1.0)*cj3*x751))+(((0.0135)*sj3))+(((-1.0)*px*x749*x756))+(((-1.0)*pz*x748))+(((0.037)*sj4))+(((-1.0)*py*sj2*x745*x749))+(((-0.1015)*cj3))+((cj3*py*x755)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x759=((1.0)*sj4);
IkReal x760=(cj2*r00);
IkReal x761=(r01*sj2);
IkReal x762=(cj3*cj4);
IkReal x763=(r02*sj3);
IkReal x764=(cj2*r01);
IkReal x765=(r00*sj2);
CheckValue<IkReal> x766=IKPowWithIntegerCheck(IKsign((((cj3*(r02*r02)))+(((-1.0)*cj3)))),-1);
if(!x766.valid){
continue;
}
CheckValue<IkReal> x767 = IKatan2WithCheck(IkReal((((x760*x763))+((x761*x763))+((x762*x764))+(((-1.0)*x762*x765))+(((-1.0)*x759*x760))+(((-1.0)*x759*x761)))),IkReal((((x760*x762))+((x761*x762))+((x763*x765))+((sj4*x764))+(((-1.0)*x763*x764))+(((-1.0)*x759*x765)))),IKFAST_ATAN2_MAGTHRESH);
if(!x767.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x766.value)))+(x767.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x768=IKcos(j1);
IkReal x769=IKsin(j1);
IkReal x770=(r01*sj3);
IkReal x771=(cj2*px);
IkReal x772=((1.0)*sj3);
IkReal x773=((1.0)*cj3);
IkReal x774=(cj3*sj2);
IkReal x775=((0.13)*cj2);
IkReal x776=(py*sj3);
IkReal x777=(cj2*r00);
IkReal x778=((1.0)*x769);
IkReal x779=(cj2*x768);
IkReal x780=(sj2*x768);
IkReal x781=(cj2*x769);
IkReal x782=(r00*x780);
evalcond[0]=(((r01*x781))+((r01*x780))+cj4+(((-1.0)*r00*sj2*x778))+((x768*x777)));
evalcond[1]=((0.213)+((py*x781))+((py*x780))+(((-0.13)*sj2))+(((-1.0)*px*sj2*x778))+((x768*x771))+(((0.037)*cj4)));
evalcond[2]=(((x770*x779))+(((-1.0)*sj2*x770*x778))+(((-1.0)*x769*x772*x777))+(((-1.0)*x772*x782))+((cj3*r02)));
evalcond[3]=(sj4+(((-1.0)*x773*x782))+(((-1.0)*x769*x773*x777))+(((-1.0)*r02*x772))+((cj3*r01*x779))+(((-1.0)*r01*sj2*x769*x773)));
evalcond[4]=((-0.0005)+(((-0.1015)*sj3))+(((-1.0)*sj3*x775))+((x776*x779))+(((-0.0135)*cj3))+(((-1.0)*px*x772*x780))+(((-1.0)*x769*x771*x772))+(((-1.0)*py*sj2*x769*x772))+((cj3*pz)));
evalcond[5]=((((-1.0)*cj3*x775))+(((0.0135)*sj3))+(((-1.0)*x769*x771*x773))+(((-1.0)*py*sj2*x769*x773))+(((-1.0)*pz*x772))+(((0.037)*sj4))+((cj3*py*x779))+(((-1.0)*px*x773*x780))+(((-0.1015)*cj3)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x783=((1.0)*r00);
IkReal x784=(cj3*r02);
IkReal x785=(cj2*r01);
IkReal x786=(cj4*sj3);
IkReal x787=(sj2*x786);
CheckValue<IkReal> x788 = IKatan2WithCheck(IkReal((((x785*x786))+(((-1.0)*r01*sj2*x784))+(((-1.0)*cj2*x783*x784))+(((-1.0)*x783*x787)))),IkReal(((((-1.0)*sj2*x783*x784))+((r01*x787))+((x784*x785))+((cj2*r00*x786)))),IKFAST_ATAN2_MAGTHRESH);
if(!x788.valid){
continue;
}
CheckValue<IkReal> x789=IKPowWithIntegerCheck(IKsign(((((-1.0)*sj3))+((sj3*(r02*r02))))),-1);
if(!x789.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x788.value)+(((1.5707963267949)*(x789.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x790=IKcos(j1);
IkReal x791=IKsin(j1);
IkReal x792=(r01*sj3);
IkReal x793=(cj2*px);
IkReal x794=((1.0)*sj3);
IkReal x795=((1.0)*cj3);
IkReal x796=(cj3*sj2);
IkReal x797=((0.13)*cj2);
IkReal x798=(py*sj3);
IkReal x799=(cj2*r00);
IkReal x800=((1.0)*x791);
IkReal x801=(cj2*x790);
IkReal x802=(sj2*x790);
IkReal x803=(cj2*x791);
IkReal x804=(r00*x802);
evalcond[0]=((((-1.0)*r00*sj2*x800))+cj4+((x790*x799))+((r01*x802))+((r01*x803)));
evalcond[1]=((0.213)+(((-1.0)*px*sj2*x800))+((x790*x793))+(((-0.13)*sj2))+((py*x803))+((py*x802))+(((0.037)*cj4)));
evalcond[2]=((((-1.0)*x791*x794*x799))+((cj3*r02))+((x792*x801))+(((-1.0)*x794*x804))+(((-1.0)*sj2*x792*x800)));
evalcond[3]=(sj4+(((-1.0)*r01*sj2*x791*x795))+(((-1.0)*x795*x804))+(((-1.0)*x791*x795*x799))+((cj3*r01*x801))+(((-1.0)*r02*x794)));
evalcond[4]=((-0.0005)+(((-0.1015)*sj3))+(((-0.0135)*cj3))+(((-1.0)*x791*x793*x794))+((x798*x801))+((cj3*pz))+(((-1.0)*px*x794*x802))+(((-1.0)*sj3*x797))+(((-1.0)*py*sj2*x791*x794)));
evalcond[5]=((((-1.0)*cj3*x797))+(((-1.0)*px*x795*x802))+(((-1.0)*x791*x793*x795))+(((0.0135)*sj3))+(((0.037)*sj4))+(((-1.0)*pz*x794))+(((-0.1015)*cj3))+(((-1.0)*py*sj2*x791*x795))+((cj3*py*x801)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=0;
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}
    }

}

}
}
}
// [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1), (3, 0), (3, 1)] (original are [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1)])
static inline bool checkconsistency8(const IkReal* Breal)
{
    IkReal norm = 0.1;
    for(int i = 0; i < 7; ++i) {
        norm += IKabs(Breal[i]);
    }
    // HACK should be 1e-5*norm
    IkReal tol = 1e-2*norm; // have to increase the threshold since many computations are involved
    return IKabs(Breal[0]*Breal[1]-Breal[2]) < tol && IKabs(Breal[1]*Breal[1]-Breal[3]) < tol && IKabs(Breal[0]*Breal[3]-Breal[4]) < tol && IKabs(Breal[1]*Breal[3]-Breal[5]) < tol && IKabs(Breal[0]*Breal[5]-Breal[6]) < tol;
}
/// \brief Solve the det Ax^2+Bx+C = 0 problem using the Manocha and Canny method (1994)
///
/// matcoeffs is of length 54*3, for 3 matrices
static inline void solvedialyticpoly8qep(const IkReal* matcoeffs, IkReal* rawroots, int& numroots)
{
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    IkReal IKFAST_ALIGNED16(M[16*16]) = {0};
    IkReal IKFAST_ALIGNED16(A[8*8]);
    IkReal IKFAST_ALIGNED16(work[16*16*15]);
    int ipiv[8];
    int info, coeffindex;
    const int worksize=16*16*15;
    const int matrixdim = 8;
    const int matrixdim2 = 16;
    numroots = 0;
    // first setup M = [0 I; -C -B] and A
    coeffindex = 0;
    for(int j = 0; j < 4; ++j) {
        for(int k = 0; k < 6; ++k) {
            M[matrixdim+(j+4)+2*matrixdim*k] = M[matrixdim+j+2*matrixdim*(k+2)] = -matcoeffs[coeffindex++];
        }
    }
    for(int j = 0; j < 4; ++j) {
        for(int k = 0; k < 6; ++k) {
            M[matrixdim+(j+4)+2*matrixdim*k+matrixdim*2*matrixdim] = M[matrixdim+j+2*matrixdim*(k+2)+matrixdim*2*matrixdim] = -matcoeffs[coeffindex++];
        }
    }
    for(int j = 0; j < 4; ++j) {
        for(int k = 0; k < 6; ++k) {
            A[(j+4)+matrixdim*k] = A[j+matrixdim*(k+2)] = matcoeffs[coeffindex++];
        }
        for(int k = 0; k < 2; ++k) {
            A[j+matrixdim*k] = A[(j+4)+matrixdim*(k+6)] = 0;
        }
    }
    const IkReal lfpossibilities[4][4] = {{1,-1,1,1},{1,0,-2,1},{1,1,2,0},{1,-1,4,1}};
    int lfindex = -1;
    bool bsingular = true;
    do {
        dgetrf_(&matrixdim,&matrixdim,A,&matrixdim,&ipiv[0],&info);
        if( info == 0 ) {
            bsingular = false;
            for(int j = 0; j < matrixdim; ++j) {
                if( IKabs(A[j*matrixdim+j]) < 100*tol ) {
                    bsingular = true;
                    break;
                }
            }
            if( !bsingular ) {
                break;
            }
        }
        if( lfindex == 3 ) {
            break;
        }
        // transform by the linear functional
        lfindex++;
        const IkReal* lf = lfpossibilities[lfindex];
        // have to reinitialize A
        coeffindex = 0;
        for(int j = 0; j < 4; ++j) {
            for(int k = 0; k < 6; ++k) {
                IkReal a = matcoeffs[coeffindex+48], b = matcoeffs[coeffindex+24], c = matcoeffs[coeffindex];
                A[(j+4)+matrixdim*k] = A[j+matrixdim*(k+2)] = lf[0]*lf[0]*a+lf[0]*lf[2]*b+lf[2]*lf[2]*c;
                M[matrixdim+(j+4)+2*matrixdim*k] = M[matrixdim+j+2*matrixdim*(k+2)] = -(lf[1]*lf[1]*a + lf[1]*lf[3]*b + lf[3]*lf[3]*c);
                M[matrixdim+(j+4)+2*matrixdim*k+matrixdim*2*matrixdim] = M[matrixdim+j+2*matrixdim*(k+2)+matrixdim*2*matrixdim] = -(2*lf[0]*lf[1]*a + (lf[0]*lf[3]+lf[1]*lf[2])*b + 2*lf[2]*lf[3]*c);
                coeffindex++;
            }
            for(int k = 0; k < 2; ++k) {
                A[j+matrixdim*k] = A[(j+4)+matrixdim*(k+6)] = 0;
            }
        }
    } while(lfindex<4);

    if( bsingular ) {
        return;
    }
    dgetrs_("No transpose", &matrixdim, &matrixdim2, A, &matrixdim, &ipiv[0], &M[matrixdim], &matrixdim2, &info);
    if( info != 0 ) {
        return;
    }

    // set identity in upper corner
    for(int j = 0; j < matrixdim; ++j) {
        M[matrixdim*2*matrixdim+j+matrixdim*2*j] = 1;
    }
    IkReal IKFAST_ALIGNED16(wr[16]);
    IkReal IKFAST_ALIGNED16(wi[16]);
    IkReal IKFAST_ALIGNED16(vr[16*16]);
    int one=1;
    printf("Before calling dgeev_ ...\n");
    dgeev_("N", "V", &matrixdim2, M, &matrixdim2, wr, wi,NULL, &one, vr, &matrixdim2, work, &worksize, &info);
    printf("Finished calling dgeev_\n");
    if( info != 0 ) {
        return;
    }
    IkReal Breal[matrixdim-1];
    for(int i = 0; i < matrixdim2; ++i) {
        // HACK should be tol*100
        if( IKabs(wi[i]) < 5e-5 ) {
            IkReal* ev = vr+matrixdim2*i;
            if( IKabs(wr[i]) > 1 ) {
                ev += matrixdim;
            }
            // consistency has to be checked!!
            if( IKabs(ev[0]) < tol ) {
                continue;
            }
            IkReal iconst = 1/ev[0];
            for(int j = 1; j < matrixdim; ++j) {
                Breal[j-1] = ev[j]*iconst;
            }
            if( checkconsistency8(Breal) ) {
                if( lfindex >= 0 ) {
                    const IkReal* lf = lfpossibilities[lfindex];
                    rawroots[numroots++] = (wr[i]*lf[0]+lf[1])/(wr[i]*lf[2]+lf[3]);
                }
                else {
                    rawroots[numroots++] = wr[i];
                }
                bool bsmall0=IKabs(ev[0]) > IKabs(ev[2]);
                bool bsmall1=IKabs(ev[0]) > IKabs(ev[1]);
                if( bsmall0 && bsmall1 ) {
                    rawroots[numroots++] = ev[2]/ev[0];
                    rawroots[numroots++] = ev[1]/ev[0];
                }
                else if( bsmall0 && !bsmall1 ) {
                    rawroots[numroots++] = ev[3]/ev[1];
                    rawroots[numroots++] = ev[1]/ev[0];
                }
                else if( !bsmall0 && bsmall1 ) {
                    rawroots[numroots++] = ev[6]/ev[4];
                    rawroots[numroots++] = ev[7]/ev[6];
                }
                else if( !bsmall0 && !bsmall1 ) {
                    rawroots[numroots++] = ev[7]/ev[5];
                    rawroots[numroots++] = ev[7]/ev[6];
                }
            }
        }
    }
}};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "beab021f34048993a898af827bc00492"; }

IKFAST_API const char* GetIkFastVersion() { return "0x1000004a"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
